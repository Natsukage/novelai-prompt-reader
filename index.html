<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NovelAI 图片解析</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      position: relative;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .header-controls {
      position: absolute;
      top: 20px;
      right: 20px;
    }

    .settings-btn {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .main-content {
      display: grid;
      grid-template-columns: 2fr 3fr;
      gap: 30px;
      align-items: start;
    }

    @media (max-width: 968px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .left-column {
        margin-bottom: 0;
      }

      .technical-panel {
        margin-bottom: 0;
      }

      .right-panel {
        margin-top: 0;
      }
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .left-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .technical-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .upload-area {
      border: 3px dashed #e0e6ed;
      border-radius: 12px;
      padding: 60px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #f8f9fc;
      width: 100%;
      min-height: 350px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .upload-area:hover {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .upload-area.drag-over {
      border-color: #667eea;
      background: #e8ebff;
      transform: scale(1.02);
    }

    .upload-area.has-image {
      padding: 20px;
      background: #fff;
      cursor: default;
      min-height: auto;
      border-color: #d0d7de;
    }

    .upload-area.has-image:hover {
      background: #f8f9fc;
      border-color: #667eea;
    }

    .upload-area.has-image .preview-image {
      cursor: pointer;
    }

    .image-info-compact {
      text-align: center;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e8ebf4;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      width: 100%;
    }

    .image-info-compact .image-filename {
      font-size: 0.95rem;
      color: #333;
      font-weight: 500;
      margin-bottom: 5px;
      white-space: nowrap;
      overflow: hidden;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .image-info-compact .image-filename:hover {
      color: #667eea;
    }

    .image-info-compact .image-details {
      font-size: 0.85rem;
      color: #666;
      cursor: help;
    }

    .section-icon {
      color: #667eea;
    }

    #uploadContent {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .upload-icon {
      font-size: 48px;
      color: #667eea;
      margin-bottom: 20px;
    }

    .upload-text {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 10px;
    }

    .upload-hint {
      color: #999;
      font-size: 0.9rem;
    }

    .preview-image {
      max-width: 100%;
      max-height: 350px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: block;
      margin: 0 auto;
      cursor: pointer;
    }

    .preview-image:hover {
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
    }

    .image-filename {
      font-size: 1.1rem;
      font-weight: 500;
      color: #333;
      margin-bottom: 10px;
      word-break: break-all;
    }

    .image-details {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: #666;
    }

    .detail-label {
      color: #999;
    }

    .detail-value {
      color: #333;
      font-weight: 500;
    }

    .right-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      max-height: 90vh;
      overflow-y: auto;
    }

    .info-section {
      margin-bottom: 30px;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #444;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-item {
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      border: 1px solid #e8ebf4;
      transition: all 0.3s ease;
    }

    .info-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .info-label {
      font-weight: 600;
      color: #555;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .info-value {
      color: #666;
      line-height: 1.6;
      word-break: break-word;
      white-space: pre-wrap;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.9rem;
    }

    .info-value.formatted-prompt {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 0.95rem;
      line-height: 1.7;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    /* Prompt权重高亮样式 */
    .prompt-tag {
      display: inline;
    }

    .prompt-tag.weight-high {
      color: #e53e3e;
    }

    .prompt-tag.weight-low {
      color: #3182ce;
    }

    .prompt-tag.weight-normal {
      color: #333;
    }

    .prompt-tag.default-tag {
      color: #a0aec0;
      opacity: 0.7;
    }

    .prompt-weight-marker {
      color: #805ad5;
      font-weight: 600;
      opacity: 0.8;
      white-space: nowrap;
    }

    .prompt-comma {
      color: #a0aec0;
    }

    .tech-params {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e8ebf4;
    }

    @media (max-width: 768px) {
      .tech-params {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 12px;
        padding: 15px;
      }
    }

    .tech-param-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      padding: 8px;
      border-radius: 6px;
      overflow-wrap: break-word;
    }

    .tech-param-item:hover {
      background-color: rgba(102, 126, 234, 0.1);
    }

    .tech-param-item.wide {
      grid-column: span 2;
    }

    .tech-param-label {
      font-size: 0.85rem;
      color: #888;
      font-weight: 500;
    }

    .tech-param-value {
      font-size: 0.95rem;
      color: #333;
      font-weight: 600;
      font-family: "Monaco", "Consolas", monospace;
    }

    .copy-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
    }

    .copy-btn:hover {
      background: #5a67d8;
      transform: translateY(-1px);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .json-viewer {
      background: #f5f7fa;
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.85rem;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #999;
    }

    .error {
      background: #fee;
      color: #c33;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }

    .footer {
      text-align: center;
      margin-top: 50px;
      padding: 20px;
      color: #999;
      font-size: 0.9rem;
      clear: both;
    }

    .footer a {
      color: #667eea;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* 滚动条样式 */
    .right-panel::-webkit-scrollbar {
      width: 8px;
    }

    .right-panel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* 动画 */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .info-item {
      animation: fadeIn 0.5s ease;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #667eea;
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* 设置面板样式 */
    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }

    .settings-modal.show {
      display: flex;
    }

    .settings-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid #e8ebf4;
    }

    .settings-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #999;
      padding: 5px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: #f0f0f0;
      color: #666;
    }

    .setting-group {
      margin-bottom: 25px;
    }

    .setting-label {
      display: block;
      font-weight: 600;
      color: #555;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .setting-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid #e0e6ed;
      border-radius: 8px;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }

    .setting-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .setting-description {
      font-size: 0.85rem;
      color: #666;
      margin-top: 5px;
      line-height: 1.4;
    }

    .setting-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
      background: #ddd;
      border-radius: 13px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .toggle-switch.active {
      background: #667eea;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(24px);
    }

    .save-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.3s ease;
      width: 100%;
    }

    .save-btn:hover {
      background: #5a67d8;
      transform: translateY(-1px);
    }

    .save-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .test-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 10px;
    }

    .test-btn:hover {
      background: #218838;
      transform: translateY(-1px);
    }

    .test-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .provider-config {
      border-left: 3px solid #667eea;
      padding-left: 15px;
      margin-left: 10px;
    }

    .test-result {
      margin-top: 15px;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .test-result.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .test-result.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    .test-result.loading {
      background: #d1ecf1;
      border: 1px solid #bee5eb;
      color: #0c5460;
    }

    /* 翻译相关样式 */
    .prompt-container {
      position: relative;
    }

    .prompt-translation {
      font-size: 0.85rem;
      color: #666;
      font-style: italic;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #f0f0f0;
      line-height: 1.7;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    .translation-loading {
      color: #999;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .translation-error {
      color: #e53e3e;
    }

    /* Tag翻译样式 */
    .translation-tag {
      display: inline;
      transition: all 0.2s ease;
      border-radius: 3px;
      padding: 1px 2px;
    }

    .translation-comma {
      color: #a0aec0;
    }

    /* 悬停高亮效果 */
    .prompt-tag.highlighted {
      background-color: rgba(102, 126, 234, 0.15);
      transform: scale(1.02);
    }

    .translation-tag.highlighted {
      background-color: rgba(102, 126, 234, 0.15);
      transform: scale(1.02);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #999;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-controls">
        <button class="settings-btn" id="settingsBtn">⚙️ 设置</button>
      </div>
      <h1>🎨 NovelAI 图片解析</h1>
      <p>从 NovelAI 生成的图片中提取详细参数信息</p>
    </div>

    <div class="main-content">
      <div class="left-column">
        <div class="left-panel">
          <div class="upload-area" id="uploadArea">
            <div id="uploadContent">
              <div class="upload-icon">📁</div>
              <div class="upload-text">拖拽图片到这里</div>
              <div class="upload-hint">或点击选择文件</div>
            </div>
            <!-- 预览图片 -->
            <img id="previewImage" class="preview-image" style="display: none" alt="预览图片" />
            <!-- 基础信息 -->
            <div class="image-info-compact" id="imageInfo" style="display: none">
              <div class="image-filename" id="imageFilename"></div>
              <div class="image-details" id="imageDetails"></div>
            </div>
            <input type="file" id="fileInput" accept="image/*" style="display: none" />
          </div>
        </div>

        <!-- 技术参数区域 -->
        <div class="technical-panel" id="technicalPanel" style="display: none">
          <div id="technicalParams" class="tech-params"></div>
        </div>
      </div>

      <div class="right-panel" id="rightPanel" style="display: none">
        <div id="infoContainer"></div>
      </div>
    </div>

    <div class="footer">
      <p>* 所有运算完全在您的设备上运行，不会上传到云端</p>
      <p>Made by <a href="https://github.com/Natsukage">@Natsukage</a></p>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- 设置面板 -->
  <div class="settings-modal" id="settingsModal">
    <div class="settings-panel">
      <div class="settings-header">
        <h2 class="settings-title">🛠️ 设置</h2>
        <button class="close-btn" id="closeSettingsBtn">×</button>
      </div>
      
      <div class="setting-group">
        <div class="setting-toggle">
          <label class="setting-label">启用AI翻译</label>
          <div class="toggle-switch" id="translationToggle">
            <div class="toggle-slider"></div>
          </div>
        </div>
        <div class="setting-description">
          开启后，将自动翻译提示词为中文。翻译结果会显示在原文下方。<br>
          <small style="color: #666;">ℹ️ 首次使用时将自动下载翻译缓存，高频词汇无需调用API。</small>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">翻译服务提供商</label>
        <select id="translationProviderSelect" class="setting-input">
          <option value="gemini">Gemini AI（免CORS配置）</option>
          <option value="tencent">腾讯云翻译（需CORS配置）</option>
          <option value="baidu">百度翻译（需CORS配置）</option>
        </select>
        <div class="setting-description">
          选择翻译服务提供商。Gemini速度慢但质量高，腾讯和百度速度快且成本低，但需要配置跨域支持。
        </div>
      </div>

      <!-- Gemini 配置 -->
      <div class="setting-group provider-config" id="geminiConfig">
        <label class="setting-label" for="apiKeyInput">Gemini API Key</label>
        <input type="password" id="apiKeyInput" class="setting-input" placeholder="输入您的 Gemini API Key">
        <div class="setting-description">
          请输入您的 Google Gemini API Key。您可以在 <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> 获取。
        </div>
      </div>

      <!-- 腾讯云配置 -->
      <div class="setting-group provider-config" id="tencentConfig" style="display: none;">
        <label class="setting-label" for="tencentSecretIdInput">腾讯云 Secret ID</label>
        <input type="password" id="tencentSecretIdInput" class="setting-input" placeholder="输入您的腾讯云 Secret ID">
        
        <label class="setting-label" for="tencentSecretKeyInput" style="margin-top: 15px;">腾讯云 Secret Key</label>
        <input type="password" id="tencentSecretKeyInput" class="setting-input" placeholder="输入您的腾讯云 Secret Key">
        
        <div class="setting-description">
          请输入您的腾讯云访问密钥。您可以在 <a href="https://console.cloud.tencent.com/cam/capi" target="_blank">腾讯云控制台</a> 获取。
          <br><strong>注意：使用前请安装CORS插件或Tampermonkey脚本！</strong>
        </div>
      </div>

      <!-- 百度翻译配置 -->
      <div class="setting-group provider-config" id="baiduConfig" style="display: none;">
        <label class="setting-label" for="baiduAppIdInput">百度翻译 App ID</label>
        <input type="text" id="baiduAppIdInput" class="setting-input" placeholder="输入您的百度翻译 App ID">
        
        <label class="setting-label" for="baiduAppKeyInput" style="margin-top: 15px;">百度翻译 App Key</label>
        <input type="password" id="baiduAppKeyInput" class="setting-input" placeholder="输入您的百度翻译 App Key">
        
        <div class="setting-description">
          请输入您的百度翻译密钥。您可以在 <a href="https://fanyi-api.baidu.com/api/trans/product/index" target="_blank">百度翻译开放平台</a> 获取。
          <br><strong>注意：使用前请安装CORS插件或Tampermonkey脚本！</strong>
        </div>
      </div>

      <!-- 连接测试 -->
      <div class="setting-group">
        <button class="test-btn" id="testConnectionBtn">测试连接</button>
        <div class="setting-description">
          点击测试当前选择的翻译服务是否可正常访问。如果测试失败，请检查API密钥和CORS配置。
        </div>
        <!-- 测试结果显示 -->
        <div id="testResult" class="test-result" style="display: none;">
          <div id="testResultContent"></div>
        </div>
      </div>

      <button class="save-btn" id="saveSettingsBtn">保存设置</button>
    </div>
  </div>

  <!-- 引入必要的库 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    // =============================================================================
    // 工具函数模块
    // =============================================================================
    
    // =============================================================================
    // 设置管理模块
    // =============================================================================
    
    const SettingsManager = {
      STORAGE_KEYS: {
        API_KEY: 'gemini_api_key',
        TRANSLATION_ENABLED: 'translation_enabled',
        TRANSLATION_PROVIDER: 'translation_provider',
        TENCENT_SECRET_ID: 'tencent_secret_id',
        TENCENT_SECRET_KEY: 'tencent_secret_key',
        BAIDU_APP_ID: 'baidu_app_id',
        BAIDU_APP_KEY: 'baidu_app_key'
      },

      getApiKey() {
        return localStorage.getItem(this.STORAGE_KEYS.API_KEY) || '';
      },

      setApiKey(key) {
        if (key) {
          localStorage.setItem(this.STORAGE_KEYS.API_KEY, key);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.API_KEY);
        }
      },

      isTranslationEnabled() {
        return localStorage.getItem(this.STORAGE_KEYS.TRANSLATION_ENABLED) === 'true';
      },

      setTranslationEnabled(enabled) {
        localStorage.setItem(this.STORAGE_KEYS.TRANSLATION_ENABLED, enabled.toString());
      },

      hasValidApiKey() {
        const key = this.getApiKey();
        return key && key.length > 0;
      },

      // 翻译服务提供商管理
      getTranslationProvider() {
        return localStorage.getItem(this.STORAGE_KEYS.TRANSLATION_PROVIDER) || 'gemini';
      },

      setTranslationProvider(provider) {
        localStorage.setItem(this.STORAGE_KEYS.TRANSLATION_PROVIDER, provider);
      },

      // 腾讯云配置管理
      getTencentSecretId() {
        return localStorage.getItem(this.STORAGE_KEYS.TENCENT_SECRET_ID) || '';
      },

      setTencentSecretId(secretId) {
        if (secretId) {
          localStorage.setItem(this.STORAGE_KEYS.TENCENT_SECRET_ID, secretId);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.TENCENT_SECRET_ID);
        }
      },

      getTencentSecretKey() {
        return localStorage.getItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY) || '';
      },

      setTencentSecretKey(secretKey) {
        if (secretKey) {
          localStorage.setItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY, secretKey);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY);
        }
      },

      // 百度翻译配置管理
      getBaiduAppId() {
        return localStorage.getItem(this.STORAGE_KEYS.BAIDU_APP_ID) || '';
      },

      setBaiduAppId(appId) {
        if (appId) {
          localStorage.setItem(this.STORAGE_KEYS.BAIDU_APP_ID, appId);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.BAIDU_APP_ID);
        }
      },

      getBaiduAppKey() {
        return localStorage.getItem(this.STORAGE_KEYS.BAIDU_APP_KEY) || '';
      },

      setBaiduAppKey(appKey) {
        if (appKey) {
          localStorage.setItem(this.STORAGE_KEYS.BAIDU_APP_KEY, appKey);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.BAIDU_APP_KEY);
        }
      },

      // 检查各服务的配置有效性
      hasValidGeminiConfig() {
        const key = this.getApiKey();
        return key && key.length > 0;
      },

      hasValidTencentConfig() {
        const secretId = this.getTencentSecretId();
        const secretKey = this.getTencentSecretKey();
        return secretId && secretId.length > 0 && secretKey && secretKey.length > 0;
      },

      hasValidBaiduConfig() {
        const appId = this.getBaiduAppId();
        const appKey = this.getBaiduAppKey();
        return appId && appId.length > 0 && appKey && appKey.length > 0;
      },

      hasValidCurrentProviderConfig() {
        const provider = this.getTranslationProvider();
        switch (provider) {
          case 'gemini':
            return this.hasValidGeminiConfig();
          case 'tencent':
            return this.hasValidTencentConfig();
          case 'baidu':
            return this.hasValidBaiduConfig();
          default:
            return false;
        }
      }
    };

    // =============================================================================
    // Gemini API 翻译模块
    // =============================================================================
    
    const GeminiTranslator = {
      API_ENDPOINT: 'https://generativelanguage.googleapis.com/v1beta/models',
      MODEL: 'gemini-2.5-flash',

      async translateTags(tagsArray) {
        const apiKey = SettingsManager.getApiKey();
        if (!apiKey || !SettingsManager.isTranslationEnabled()) {
          return [];
        }

        try {
          // 过滤掉空标签和权重标记
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const promptText = `你是一个专业的AI绘画提示词翻译助手。我会给你一个英文AI绘画标签(tags)的数组，请将每个标签翻译成中文。

要求：
1. 保持专业术语的准确性
2. 尽量保持原意，对于艺术家名等不要翻译。
3. 翻译要简洁准确且易懂，例如对于dutch angle等术语，需要翻译为斜角镜头等易懂的词汇
4. 直接返回翻译后的数组，格式如：["翻译1", "翻译2", "翻译3"]

请只返回JSON数组，不要包含其他内容。

需要翻译的标签数组：
${JSON.stringify(validTags)}`;

          const requestBody = {
            contents: [
              {
                role: "user",
                parts: [
                  {
                    text: promptText
                  }
                ]
              }
            ],
            generationConfig: {
              responseMimeType: "text/plain",
              temperature: 0.2
            }
          };

          const response = await fetch(`${this.API_ENDPOINT}/${this.MODEL}:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            throw new Error(`API请求失败: ${response.status} ${response.statusText}`);
          }

          const data = await response.json();
          const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
          
          if (!content) {
            throw new Error('API返回内容为空');
          }

          // 解析JSON响应
          let translations;
          try {
            translations = JSON.parse(content.trim());
          } catch (e) {
            // 如果不是JSON格式，尝试提取JSON数组部分
            const jsonMatch = content.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
              translations = JSON.parse(jsonMatch[0]);
            } else {
              throw new Error('无法解析翻译结果');
            }
          }

          if (!Array.isArray(translations)) {
            throw new Error('翻译结果格式错误');
          }

          return translations;

        } catch (error) {
          console.error('翻译失败:', error);
          showToast(`翻译失败: ${error.message}`);
          return [];
        }
      }
    };

    // =============================================================================
    // 翻译服务提供商枚举和工具函数
    // =============================================================================
    
    const TranslationProviders = {
      GEMINI: 'gemini',
      TENCENT: 'tencent',
      BAIDU: 'baidu'
    };

    // 工具函数：加密和签名
    const CryptoUtils = {
      // SHA256 哈希函数
      async sha256(message) {
        const msgBuffer = new TextEncoder().encode(message);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      },

      // HMAC-SHA256 签名函数
      async hmacSha256(key, message) {
        let keyData, messageData;
        
        // 如果key是字符串，转换为字节数组；如果是hex字符串，先转换为二进制
        if (typeof key === 'string') {
          if (key.match(/^[0-9a-fA-F]+$/) && key.length % 2 === 0 && key.length > 10) {
            // 这是一个hex字符串，转换为二进制
            keyData = new Uint8Array(key.match(/.{2}/g).map(byte => parseInt(byte, 16)));
          } else {
            // 这是普通字符串
            keyData = new TextEncoder().encode(key);
          }
        } else {
          keyData = key;
        }
        
        messageData = new TextEncoder().encode(message);
        
        const cryptoKey = await crypto.subtle.importKey(
          'raw',
          keyData,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign']
        );
        
        const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
        const hashArray = Array.from(new Uint8Array(signature));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      },

      // MD5 哈希函数（用于百度翻译）
      md5(str) {
        function rotateLeft(value, amount) {
          return (value << amount) | (value >>> (32 - amount));
        }

        function addUnsigned(x, y) {
          const x4 = (x & 0x40000000);
          const y4 = (y & 0x40000000);
          const x8 = (x & 0x80000000);
          const y8 = (y & 0x80000000);
          const result = (x & 0x3FFFFFFF) + (y & 0x3FFFFFFF);
          if (x4 & y4) {
            return (result ^ 0x80000000 ^ x8 ^ y8);
          }
          if (x4 | y4) {
            if (result & 0x40000000) {
              return (result ^ 0xC0000000 ^ x8 ^ y8);
            } else {
              return (result ^ 0x40000000 ^ x8 ^ y8);
            }
          } else {
            return (result ^ x8 ^ y8);
          }
        }

        function f(x, y, z) {
          return (x & y) | ((~x) & z);
        }

        function g(x, y, z) {
          return (x & z) | (y & (~z));
        }

        function h(x, y, z) {
          return (x ^ y ^ z);
        }

        function i(x, y, z) {
          return (y ^ (x | (~z)));
        }

        function ff(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function gg(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function hh(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function ii(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function convertToWordArray(str) {
          let wordArray = [];
          let messageLength = str.length;
          let numberOfWords = (((messageLength + 8) - ((messageLength + 8) % 64)) / 64 + 1) * 16;
          
          for (let i = 0; i < numberOfWords; i++) {
            wordArray[i] = 0;
          }
          
          for (let i = 0; i < messageLength; i++) {
            wordArray[i >>> 2] |= str.charCodeAt(i) << ((i % 4) * 8);
          }
          
          wordArray[messageLength >>> 2] |= 0x80 << ((messageLength % 4) * 8);
          wordArray[numberOfWords - 2] = messageLength * 8;
          
          return wordArray;
        }

        function wordToHex(value) {
          let hex = "";
          for (let i = 0; i <= 3; i++) {
            const byte = (value >>> (i * 8)) & 255;
            hex += ("0" + byte.toString(16)).substr(-2);
          }
          return hex;
        }

        const wordArray = convertToWordArray(str);
        let h0 = 0x67452301;
        let h1 = 0xEFCDAB89;
        let h2 = 0x98BADCFE;
        let h3 = 0x10325476;

        for (let i = 0; i < wordArray.length; i += 16) {
          let a = h0;
          let b = h1;
          let c = h2;
          let d = h3;

          // Round 1
          a = ff(a, b, c, d, wordArray[i + 0], 7, 0xD76AA478);
          d = ff(d, a, b, c, wordArray[i + 1], 12, 0xE8C7B756);
          c = ff(c, d, a, b, wordArray[i + 2], 17, 0x242070DB);
          b = ff(b, c, d, a, wordArray[i + 3], 22, 0xC1BDCEEE);
          a = ff(a, b, c, d, wordArray[i + 4], 7, 0xF57C0FAF);
          d = ff(d, a, b, c, wordArray[i + 5], 12, 0x4787C62A);
          c = ff(c, d, a, b, wordArray[i + 6], 17, 0xA8304613);
          b = ff(b, c, d, a, wordArray[i + 7], 22, 0xFD469501);
          a = ff(a, b, c, d, wordArray[i + 8], 7, 0x698098D8);
          d = ff(d, a, b, c, wordArray[i + 9], 12, 0x8B44F7AF);
          c = ff(c, d, a, b, wordArray[i + 10], 17, 0xFFFF5BB1);
          b = ff(b, c, d, a, wordArray[i + 11], 22, 0x895CD7BE);
          a = ff(a, b, c, d, wordArray[i + 12], 7, 0x6B901122);
          d = ff(d, a, b, c, wordArray[i + 13], 12, 0xFD987193);
          c = ff(c, d, a, b, wordArray[i + 14], 17, 0xA679438E);
          b = ff(b, c, d, a, wordArray[i + 15], 22, 0x49B40821);

          // Round 2
          a = gg(a, b, c, d, wordArray[i + 1], 5, 0xF61E2562);
          d = gg(d, a, b, c, wordArray[i + 6], 9, 0xC040B340);
          c = gg(c, d, a, b, wordArray[i + 11], 14, 0x265E5A51);
          b = gg(b, c, d, a, wordArray[i + 0], 20, 0xE9B6C7AA);
          a = gg(a, b, c, d, wordArray[i + 5], 5, 0xD62F105D);
          d = gg(d, a, b, c, wordArray[i + 10], 9, 0x02441453);
          c = gg(c, d, a, b, wordArray[i + 15], 14, 0xD8A1E681);
          b = gg(b, c, d, a, wordArray[i + 4], 20, 0xE7D3FBC8);
          a = gg(a, b, c, d, wordArray[i + 9], 5, 0x21E1CDE6);
          d = gg(d, a, b, c, wordArray[i + 14], 9, 0xC33707D6);
          c = gg(c, d, a, b, wordArray[i + 3], 14, 0xF4D50D87);
          b = gg(b, c, d, a, wordArray[i + 8], 20, 0x455A14ED);
          a = gg(a, b, c, d, wordArray[i + 13], 5, 0xA9E3E905);
          d = gg(d, a, b, c, wordArray[i + 2], 9, 0xFCEFA3F8);
          c = gg(c, d, a, b, wordArray[i + 7], 14, 0x676F02D9);
          b = gg(b, c, d, a, wordArray[i + 12], 20, 0x8D2A4C8A);

          // Round 3
          a = hh(a, b, c, d, wordArray[i + 5], 4, 0xFFFA3942);
          d = hh(d, a, b, c, wordArray[i + 8], 11, 0x8771F681);
          c = hh(c, d, a, b, wordArray[i + 11], 16, 0x6D9D6122);
          b = hh(b, c, d, a, wordArray[i + 14], 23, 0xFDE5380C);
          a = hh(a, b, c, d, wordArray[i + 1], 4, 0xA4BEEA44);
          d = hh(d, a, b, c, wordArray[i + 4], 11, 0x4BDECFA9);
          c = hh(c, d, a, b, wordArray[i + 7], 16, 0xF6BB4B60);
          b = hh(b, c, d, a, wordArray[i + 10], 23, 0xBEBFBC70);
          a = hh(a, b, c, d, wordArray[i + 13], 4, 0x289B7EC6);
          d = hh(d, a, b, c, wordArray[i + 0], 11, 0xEAA127FA);
          c = hh(c, d, a, b, wordArray[i + 3], 16, 0xD4EF3085);
          b = hh(b, c, d, a, wordArray[i + 6], 23, 0x04881D05);
          a = hh(a, b, c, d, wordArray[i + 9], 4, 0xD9D4D039);
          d = hh(d, a, b, c, wordArray[i + 12], 11, 0xE6DB99E5);
          c = hh(c, d, a, b, wordArray[i + 15], 16, 0x1FA27CF8);
          b = hh(b, c, d, a, wordArray[i + 2], 23, 0xC4AC5665);

          // Round 4
          a = ii(a, b, c, d, wordArray[i + 0], 6, 0xF4292244);
          d = ii(d, a, b, c, wordArray[i + 7], 10, 0x432AFF97);
          c = ii(c, d, a, b, wordArray[i + 14], 15, 0xAB9423A7);
          b = ii(b, c, d, a, wordArray[i + 5], 21, 0xFC93A039);
          a = ii(a, b, c, d, wordArray[i + 12], 6, 0x655B59C3);
          d = ii(d, a, b, c, wordArray[i + 3], 10, 0x8F0CCC92);
          c = ii(c, d, a, b, wordArray[i + 10], 15, 0xFFEFF47D);
          b = ii(b, c, d, a, wordArray[i + 1], 21, 0x85845DD1);
          a = ii(a, b, c, d, wordArray[i + 8], 6, 0x6FA87E4F);
          d = ii(d, a, b, c, wordArray[i + 15], 10, 0xFE2CE6E0);
          c = ii(c, d, a, b, wordArray[i + 6], 15, 0xA3014314);
          b = ii(b, c, d, a, wordArray[i + 13], 21, 0x4E0811A1);
          a = ii(a, b, c, d, wordArray[i + 4], 6, 0xF7537E82);
          d = ii(d, a, b, c, wordArray[i + 11], 10, 0xBD3AF235);
          c = ii(c, d, a, b, wordArray[i + 2], 15, 0x2AD7D2BB);
          b = ii(b, c, d, a, wordArray[i + 9], 21, 0xEB86D391);

          h0 = addUnsigned(h0, a);
          h1 = addUnsigned(h1, b);
          h2 = addUnsigned(h2, c);
          h3 = addUnsigned(h3, d);
        }

        return wordToHex(h0) + wordToHex(h1) + wordToHex(h2) + wordToHex(h3);
      }
    };

    // =============================================================================
    // 腾讯云翻译模块
    // =============================================================================
    
    const TencentTranslator = {
      endpoint: 'tmt.tencentcloudapi.com',
      service: 'tmt',
      version: '2018-03-21',
      region: 'ap-beijing',
      action: 'TextTranslate',

      // 构建规范请求
      async buildCanonicalRequest(params) {
        const httpMethod = 'POST';
        const canonicalUri = '/';
        const canonicalQueryString = '';
        const canonicalHeaders = `content-type:application/json\nhost:${this.endpoint}\nx-tc-action:${this.action.toLowerCase()}\n`;
        const signedHeaders = 'content-type;host;x-tc-action';
        const payload = JSON.stringify(params);
        const hashedPayload = await CryptoUtils.sha256(payload);
        
        return `${httpMethod}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${hashedPayload}`;
      },

      // 构建待签名字符串
      async buildStringToSign(canonicalRequest, timestamp) {
        const algorithm = 'TC3-HMAC-SHA256';
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        const credentialScope = `${date}/${this.service}/tc3_request`;
        const hashedCanonicalRequest = await CryptoUtils.sha256(canonicalRequest);
        
        return `${algorithm}\n${timestamp}\n${credentialScope}\n${hashedCanonicalRequest}`;
      },

      // 计算签名
      async calculateSignature(stringToSign, secretKey, timestamp) {
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        
        const kDate = await CryptoUtils.hmacSha256('TC3' + secretKey, date);
        const kService = await CryptoUtils.hmacSha256(kDate, this.service);
        const kSigning = await CryptoUtils.hmacSha256(kService, 'tc3_request');
        const signature = await CryptoUtils.hmacSha256(kSigning, stringToSign);
        
        return signature;
      },

      // 构建Authorization头
      async buildAuthorizationHeader(params, secretId, secretKey, timestamp) {
        const canonicalRequest = await this.buildCanonicalRequest(params);
        const stringToSign = await this.buildStringToSign(canonicalRequest, timestamp);
        const signature = await this.calculateSignature(stringToSign, secretKey, timestamp);
        
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        const credentialScope = `${date}/${this.service}/tc3_request`;
        const signedHeaders = 'content-type;host;x-tc-action';
        
        return `TC3-HMAC-SHA256 Credential=${secretId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
      },

      async translateTags(tagsArray) {
        const secretId = SettingsManager.getTencentSecretId();
        const secretKey = SettingsManager.getTencentSecretKey();
        
        if (!secretId || !secretKey) {
          throw new Error('腾讯云密钥配置缺失，请在设置中配置Secret ID和Secret Key');
        }

        try {
          // 过滤掉空标签和权重标记
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const text = validTags.join('\n');
          const timestamp = Math.floor(Date.now() / 1000);
          
          const params = {
            SourceText: text,
            Source: 'en',
            Target: 'zh',
            ProjectId: 0
          };

          const authorizationHeader = await this.buildAuthorizationHeader(params, secretId, secretKey, timestamp);

          const headers = {
            'Authorization': authorizationHeader,
            'Content-Type': 'application/json',
            'Host': this.endpoint,
            'X-TC-Action': this.action,
            'X-TC-Timestamp': timestamp.toString(),
            'X-TC-Version': this.version,
            'X-TC-Region': this.region
          };

          const response = await fetch(`https://${this.endpoint}/`, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(params)
          });

          if (!response.ok) {
            throw new Error(`腾讯翻译API请求失败: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.Response.Error) {
            throw new Error(`腾讯翻译错误: ${result.Response.Error.Message}`);
          }

          // 分割翻译结果
          const translations = result.Response.TargetText.split('\n');
          return translations;

        } catch (error) {
          console.error('腾讯翻译失败:', error);
          throw error;
        }
      }
    };

    // =============================================================================
    // 百度翻译模块
    // =============================================================================
    
    const BaiduTranslator = {
      endpoint: 'https://fanyi-api.baidu.com/api/trans/vip/translate',

      // 生成MD5签名
      generateSign(query, appid, salt, appkey) {
        const signStr = appid + query + salt + appkey;
        return CryptoUtils.md5(signStr);
      },

      async translateTags(tagsArray) {
        const appid = SettingsManager.getBaiduAppId();
        const appkey = SettingsManager.getBaiduAppKey();
        
        if (!appid || !appkey) {
          throw new Error('百度翻译密钥配置缺失，请在设置中配置App ID和App Key');
        }

        try {
          // 过滤掉空标签和权重标记
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const query = validTags.join('\n');
          const salt = Date.now().toString();
          const sign = this.generateSign(query, appid, salt, appkey);

          const params = new URLSearchParams({
            q: query,
            from: 'en',
            to: 'zh',
            appid: appid,
            salt: salt,
            sign: sign
          });

          const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: params
          });

          if (!response.ok) {
            throw new Error(`百度翻译API请求失败: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();

          if (result.error_code) {
            throw new Error(`百度翻译错误(${result.error_code}): ${result.error_msg || '未知错误'}`);
          }

          // 处理百度翻译的返回格式
          if (!result.trans_result || !Array.isArray(result.trans_result)) {
            throw new Error('百度翻译返回格式错误');
          }

          // 百度翻译返回格式: {trans_result: [{src: '', dst: ''}]}
          // 如果是多个句子，会返回多个对象
          if (result.trans_result.length === 1) {
            // 单个翻译结果，按换行符分割
            return result.trans_result[0].dst.split('\n');
          } else {
            // 多个翻译结果
            return result.trans_result.map(item => item.dst);
          }

        } catch (error) {
          console.error('百度翻译失败:', error);
          throw error;
        }
      }
    };

    // =============================================================================
    // 统一翻译管理器
    // =============================================================================
    
    const TranslationManager = {
      providers: {},
      localCache: new Map(),
      cacheLoaded: false,
      cacheLoading: false,
      cacheUrl: 'https://ghfast.top/https://raw.githubusercontent.com/Natsukage/novelai-prompt-reader/main/translations.json',

      init() {
        this.providers = {
          [TranslationProviders.GEMINI]: GeminiTranslator,
          [TranslationProviders.TENCENT]: TencentTranslator,
          [TranslationProviders.BAIDU]: BaiduTranslator
        };
      },

      async loadLocalCache() {
        if (this.cacheLoaded || this.cacheLoading) {
          return;
        }

        this.cacheLoading = true;
        try {
          const response = await fetch(this.cacheUrl);
          if (!response.ok) {
            throw new Error(`加载缓存失败: ${response.status}`);
          }
          
          const translations = await response.json();
          this.localCache = new Map(Object.entries(translations));
          this.cacheLoaded = true;
          console.log(`本地翻译缓存加载成功，包含 ${this.localCache.size} 个翻译条目`);
        } catch (error) {
          console.warn('本地翻译缓存加载失败:', error);
        } finally {
          this.cacheLoading = false;
        }
      },

      getCachedTranslation(text) {
        if (!this.cacheLoaded) {
          return null;
        }
        return this.localCache.get(text.toLowerCase().trim());
      },

      async translateWithCache(tags) {
        if (!this.cacheLoaded && !this.cacheLoading) {
          this.loadLocalCache();
        }

        if (this.cacheLoaded) {
          const results = [];
          const uncachedTags = [];
          
          for (const tag of tags) {
            const cached = this.getCachedTranslation(tag);
            if (cached) {
              results.push(cached);
            } else {
              uncachedTags.push(tag);
              results.push(null);
            }
          }
          
          if (uncachedTags.length === 0) {
            return results;
          }
          
          try {
            const apiResults = await this.robustTranslateTags(uncachedTags);
            let apiIndex = 0;
            
            for (let i = 0; i < results.length; i++) {
              if (results[i] === null) {
                results[i] = apiResults[apiIndex];
                apiIndex++;
              }
            }
            
            return results;
          } catch (error) {
            console.warn('API翻译失败，返回部分缓存结果:', error);
            return results.map((result, index) => result || tags[index]);
          }
        }
        
        return await this.robustTranslateTags(tags);
      },

      async translateTags(tags, provider = null) {
        if (!this.providers[TranslationProviders.GEMINI]) {
          this.init();
        }

        const currentProvider = provider || SettingsManager.getTranslationProvider();
        
        if (!this.providers[currentProvider]) {
          throw new Error(`不支持的翻译服务提供商: ${currentProvider}`);
        }

        return await this.providers[currentProvider].translateTags(tags);
      },

      async translate(tags) {
        try {
          return await this.translateWithCache(tags);
        } catch (error) {
          console.warn('翻译失败:', error);
          return tags;
        }
      },

      // 健壮翻译（带降级机制）
      async robustTranslateTags(tags) {
        const primaryProvider = SettingsManager.getTranslationProvider();
        const fallbackProviders = [TranslationProviders.GEMINI, TranslationProviders.TENCENT, TranslationProviders.BAIDU]
          .filter(p => p !== primaryProvider);

        // 尝试主要提供商
        try {
          if (SettingsManager.hasValidCurrentProviderConfig()) {
            return await this.translateTags(tags, primaryProvider);
          } else {
            throw new Error(`${primaryProvider} 配置无效`);
          }
        } catch (error) {
          console.warn(`${primaryProvider} 翻译失败，尝试降级:`, error);
          
          // 尝试降级到其他提供商
          for (const provider of fallbackProviders) {
            try {
              // 检查配置有效性
              let hasValidConfig = false;
              switch (provider) {
                case TranslationProviders.GEMINI:
                  hasValidConfig = SettingsManager.hasValidGeminiConfig();
                  break;
                case TranslationProviders.TENCENT:
                  hasValidConfig = SettingsManager.hasValidTencentConfig();
                  break;
                case TranslationProviders.BAIDU:
                  hasValidConfig = SettingsManager.hasValidBaiduConfig();
                  break;
              }

              if (!hasValidConfig) {
                console.warn(`${provider} 配置无效，跳过`);
                continue;
              }

              const result = await this.translateTags(tags, provider);
              showToast(`已降级使用 ${provider} 翻译服务`);
              return result;
            } catch (fallbackError) {
              console.warn(`${provider} 降级翻译也失败:`, fallbackError);
            }
          }
          
          throw new Error('所有翻译服务都不可用，请检查网络连接和API配置');
        }
      }
    };

    // =============================================================================
    // DOM工具函数
    const DOMUtils = {
      getElementById(id) {
        const element = document.getElementById(id);
        if (!element) {
          console.warn(`Element with id '${id}' not found`);
        }
        return element;
      },

      toggleElementDisplay(elementId, show) {
        const element = this.getElementById(elementId);
        if (element) {
          element.style.display = show ? "block" : "none";
        }
      },

      setElementContent(elementId, content) {
        const element = this.getElementById(elementId);
        if (element) {
          element.innerHTML = content;
        }
      }
    };

    // 错误处理工具
    const ErrorHandler = {
      logError(message, error) {
        console.error(message, error);
      },

      handleProcessingError(error, context = "未知操作") {
        this.logError(`${context}时出错:`, error);
        showToast(`${context}时出错，请重试`);
      }
    };

    function showToast(message) {
      const toast = DOMUtils.getElementById("toast");
      if (toast) {
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }
    }

    function copyToClipboard(text) {
      navigator.clipboard
        .writeText(text)
        .then(() => {
          showToast("复制成功！");
        })
        .catch(() => {
          showToast("复制失败，请手动复制");
        });
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + " B";
      else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + " KB";
      else return (bytes / 1048576).toFixed(2) + " MB";
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // =============================================================================
    // 文件处理模块
    // =============================================================================
    
    // 处理文件名显示 - 中间省略，保留扩展名
    function truncateFilename(filename, maxWidth) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      context.font = '0.95rem -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

      // 如果文件名宽度小于最大宽度，直接返回
      if (context.measureText(filename).width <= maxWidth) {
        return filename;
      }

      // 提取文件名和扩展名
      const lastDotIndex = filename.lastIndexOf(".");
      const extension = lastDotIndex !== -1 ? filename.substring(lastDotIndex) : "";
      const nameWithoutExt = lastDotIndex !== -1 ? filename.substring(0, lastDotIndex) : filename;

      // 计算省略号和扩展名的宽度
      const ellipsisWidth = context.measureText("...").width;
      const extensionWidth = context.measureText(extension).width;

      // 预留至少3个字符的空间在省略号前，防止省略号紧贴扩展名
      const minEndChars = Math.min(3, Math.floor(nameWithoutExt.length / 2));
      const endPart = nameWithoutExt.substring(nameWithoutExt.length - minEndChars);
      const endPartWidth = context.measureText(endPart).width;

      const totalEndWidth = ellipsisWidth + endPartWidth + extensionWidth;
      const availableWidth = maxWidth - totalEndWidth;

      // 二分查找合适的截断长度
      let start = 0;
      let end = nameWithoutExt.length - minEndChars;
      let bestLength = 0;

      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const truncated = nameWithoutExt.substring(0, mid);
        const width = context.measureText(truncated).width;

        if (width <= availableWidth) {
          bestLength = mid;
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }

      if (bestLength === 0) {
        return "..." + endPart + extension;
      }

      return nameWithoutExt.substring(0, bestLength) + "..." + endPart + extension;
    }

    // =============================================================================
    // 配置和常量模块
    // =============================================================================
    
    const CONFIG = {
      // 界面配置
      UI: {
        FILENAME_MAX_WIDTH: 250,
        TOAST_DURATION: 3000,
        ANIMATION_DELAY_STEP: 0.1
      },

      // NovelAI配置
      NOVELAI: {
        DEFAULT_POSITIVE_TAGS: ["very aesthetic", "masterpiece", "no text"],
        DEFAULT_NEGATIVE_TAGS: [
          "nsfw","lowres","artistic error","film grain","scan artifacts","worst quality","bad quality",
          "jpeg artifacts","very displeasing","chromatic aberration","dithering","halftone",
          "screentone","multiple views","logo","too many watermarks","negative space","blank page"
        ],
        WEIGHT_MULTIPLIER: 1.1,
        STEGANOGRAPHY_MAGIC: "stealth_pngcomp"
      },

      // 支持的文件类型
      SUPPORTED_FILE_TYPES: ["image/png", "image/jpeg", "image/jpg"],
      
      // 元数据类型
      METADATA_TYPES: {
        SD_WEBUI: "SD-WEBUI",
        NOVELAI: "NOVELAI", 
        UNKNOWN: "UNKNOWN"
      }
    };

    // =============================================================================
    // Prompt处理模块
    // =============================================================================

    // Prompt格式化函数
    function formatPrompt(prompt) {
      if (!prompt || typeof prompt !== "string") return prompt;

      // 1. 去除转义字符
      let formatted = prompt.replace(/\\([()])/g, "$1");
      // 2. 去除多余的连续逗号
      formatted = formatted.replace(/,{2,}/g, ",");
      // 3. 标准化逗号后的空格：确保逗号后有且仅有一个空格
      formatted = formatted.replace(/,\s*/g, ", ");
      // 4. 去除开头和结尾的逗号和空格
      formatted = formatted.replace(/^[\s,]+|[\s,]+$/g, "");

      return formatted;
    }

    // 检查是否为默认tag
    function isDefaultTag(tagContent, isNegativePrompt = false) {
      const content = tagContent.toLowerCase().trim();
      const defaultTags = isNegativePrompt ? CONFIG.NOVELAI.DEFAULT_NEGATIVE_TAGS : CONFIG.NOVELAI.DEFAULT_POSITIVE_TAGS;
      return defaultTags.some((defaultTag) => content === defaultTag.toLowerCase() || content.includes(defaultTag.toLowerCase()));
    }

    // NovelAI权重解析器
    function parsePromptWeights(prompt) {
      const tokens = [];
      let i = 0;
      let currentWeight = 1.0;
      const weightStack = [1.0]; // 用于处理嵌套权重

      while (i < prompt.length) {
        const char = prompt[i];

        // 处理数字权重语法：数字::
        if (char.match(/[-\d]/) && prompt.substring(i).match(/^[-\d.]+::/)) {
          const match = prompt.substring(i).match(/^([-\d.]+)::/);
          if (match) {
            const weight = parseFloat(match[1]);
            tokens.push({
              type: "weight-marker",
              content: match[0],
              weight: weight,
            });
            currentWeight = weight;
            weightStack.push(weight); // 推入新权重
            i += match[0].length;
            continue;
          }
        }

        // 处理权重结束标记：::
        if (prompt.substring(i, i + 2) === "::") {
          tokens.push({
            type: "weight-marker",
            content: "::",
            weight: 1.0,
          });
          // 恢复到权重栈的上一层
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i += 2;
          continue;
        }

        // 处理旧式权重：{ 和 [
        if (char === "{") {
          const newWeight = currentWeight * CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "{",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "[") {
          const newWeight = currentWeight / CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "[",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "}" || char === "]") {
          tokens.push({
            type: "weight-marker",
            content: char,
            weight: 1.0,
          });
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i++;
          continue;
        }

        // 处理逗号
        if (char === ",") {
          tokens.push({
            type: "comma",
            content: char,
            weight: 1.0,
          });
          i++;
          // 跳过逗号后的空格
          while (i < prompt.length && prompt[i] === " ") {
            i++;
          }
          continue;
        }

        // 跳过其他空格
        if (char === " ") {
          i++;
          continue;
        }

        // 处理普通文本
        let textContent = "";
        while (i < prompt.length) {
          const currentChar = prompt[i];
          const nextTwoChars = prompt.substring(i, i + 2);

          // 检查是否遇到权重标记的开始
          if (prompt.substring(i).match(/^[-\d.]+::/)) {
            break;
          }

          // 检查是否遇到权重结束标记
          if (nextTwoChars === "::") {
            break;
          }

          // 检查是否遇到括号或逗号
          if ("{[}],".includes(currentChar)) {
            break;
          }

          textContent += currentChar;
          i++;
        }

        if (textContent.trim()) {
          tokens.push({
            type: "text",
            content: textContent.trim(),
            weight: currentWeight,
          });
        }
      }

      return tokens;
    }

    // 提取prompt中的纯文本tags（用于翻译）
    function extractTextTags(prompt) {
      const formatted = formatPrompt(prompt);
      const tokens = parsePromptWeights(formatted);
      
      return tokens
        .filter(token => token.type === "text" && token.content && token.content.trim())
        .map(token => token.content.trim());
    }

    // 渲染权重高亮的Prompt
    function renderHighlightedPrompt(prompt, isNegativePrompt = false) {
      const formatted = formatPrompt(prompt);
      const tokens = parsePromptWeights(formatted);

      let html = "";
      let textTagIndex = 0; // 用于追踪文本tag的索引

      tokens.forEach((token, index) => {
        if (token.type === "weight-marker") {
          html += `<span class="prompt-weight-marker">${escapeHtml(token.content)}</span>`;
        } else if (token.type === "comma") {
          // 在逗号后添加真实空格，给浏览器正确的换行位置
          html += `<span class="prompt-comma">${escapeHtml(token.content)}</span> `;
        } else if (token.type === "text" && token.content) {
          let className = "prompt-tag weight-normal";

          // 检查是否为默认tag
          const isDefault = isDefaultTag(token.content, isNegativePrompt);

          if (isDefault) {
            className = "prompt-tag default-tag";
          } else if (Math.abs(token.weight) > 1.0) {
            className = "prompt-tag weight-high";
          } else if (Math.abs(token.weight) < 1.0 && token.weight !== 0) {
            className = "prompt-tag weight-low";
          }

          // 添加data-tag-index用于悬停效果
          html += `<span class="${className}" data-tag-index="${textTagIndex}">${escapeHtml(token.content)}</span>`;
          textTagIndex++;

          // 在文本token后添加空格，除非下一个token是逗号或权重标记
          if (index < tokens.length - 1) {
            const nextToken = tokens[index + 1];
            if (nextToken.type !== "comma" && nextToken.type !== "weight-marker") {
              html += " ";
            }
          }
        }
      });

      return html;
    }

    // 渲染翻译结果
    function renderTranslatedTags(translations) {
      let html = "";
      
      translations.forEach((translation, index) => {
        if (index > 0) {
          html += `<span class="translation-comma">, </span>`;
        }
        html += `<span class="translation-tag" data-tag-index="${index}">${escapeHtml(translation)}</span>`;
      });
      
      return html;
    }

    // =============================================================================
    // 图片元数据解析模块
    // =============================================================================
    
    // PNG Chunk 解析
    function extractPngChunks(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      const chunks = [];
      let offset = 8; // Skip PNG signature

      while (offset < arrayBuffer.byteLength - 12) {
        const length = dataView.getUint32(offset, false);
        const type = String.fromCharCode(
          dataView.getUint8(offset + 4),
          dataView.getUint8(offset + 5),
          dataView.getUint8(offset + 6),
          dataView.getUint8(offset + 7)
        );

        const data = new Uint8Array(arrayBuffer, offset + 8, length);
        chunks.push({ type, data });

        offset += length + 12; // length + type + data + crc
      }

      return chunks;
    }

    function decodePngTextChunk(data, chunkType) {
      if (chunkType === "tEXt") {
        const nullIndex = data.indexOf(0);
        const keyword = new TextDecoder().decode(data.slice(0, nullIndex));
        const text = new TextDecoder().decode(data.slice(nullIndex + 1));
        return { keyword, text };
      } else if (chunkType === "iTXt") {
        // iTXt格式更复杂，包含压缩标志和语言标签
        const filteredData = data.filter((x) => x != 0x0);
        const header = new TextDecoder().decode(filteredData.slice(0, 11));
        if (header === "Description") {
          const txt = new TextDecoder().decode(filteredData.slice(11));
          return { keyword: "Description", text: txt };
        } else {
          const txt = new TextDecoder().decode(filteredData);
          return { keyword: "Comment", text: txt };
        }
      }
      return { keyword: "Unknown", text: "" };
    }

    // 提取元数据
    async function extractMetadata(file) {
      if (file.type === "image/png") {
        const buf = await file.arrayBuffer();
        let chunks = [];
        try {
          chunks = extractPngChunks(buf);
        } catch (err) {
          console.error("PNG chunk 解析失败:", err);
          return [];
        }

        const textChunks = chunks
          .filter(function (chunk) {
            return chunk.type === "tEXt" || chunk.type === "iTXt";
          })
          .map(function (chunk) {
            return decodePngTextChunk(chunk.data, chunk.type);
          })
          .filter(chunk => chunk.keyword !== "Unknown");

        console.log("提取的文本块:", textChunks);
        return textChunks;
      }
      return [];
    }

    // =============================================================================
    // 隐写术解析模块
    // =============================================================================
    
    // 隐写术EXIF提取
    async function getStealthExif(src) {
      let time = performance.now();

      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: true });
      let img = new Image();
      img.src = src;

      await img.decode();

      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      let imageData = ctx.getImageData(0, 0, img.width, img.height);
      let lowestData = [];

      for (let x = 0; x < img.width; x++) {
        for (let y = 0; y < img.height; y++) {
          let index = (y * img.width + x) * 4;
          let a = imageData.data[index + 3];
          lowestData.push(a & 1);
        }
      }

      console.log("隐写术提取耗时: ", performance.now() - time, "ms");

      // 数据读取器类
      class DataReader {
        constructor(data) {
          this.data = data;
          this.index = 0;
        }

        readBit() {
          return this.data[this.index++];
        }

        readNBits(n) {
          let bits = [];
          for (let i = 0; i < n; i++) {
            bits.push(this.readBit());
          }
          return bits;
        }

        readByte() {
          let byte = 0;
          for (let i = 0; i < 8; i++) {
            byte |= this.readBit() << (7 - i);
          }
          return byte;
        }

        readNBytes(n) {
          let bytes = [];
          for (let i = 0; i < n; i++) {
            bytes.push(this.readByte());
          }
          return bytes;
        }

        readInt32() {
          let bytes = this.readNBytes(4);
          return new DataView(new Uint8Array(bytes).buffer).getInt32(0, false);
        }
      }

      const magic = CONFIG.NOVELAI.STEGANOGRAPHY_MAGIC;
      const reader = new DataReader(lowestData);
      const readMagic = reader.readNBytes(magic.length);
      const magicString = String.fromCharCode.apply(null, readMagic);

      if (magic === magicString) {
        console.log("找到隐写数据！");
        const dataLength = reader.readInt32();
        console.log("数据长度:", dataLength);
        const gzipData = reader.readNBytes(dataLength / 8);

        const data = pako.ungzip(new Uint8Array(gzipData));
        const jsonString = new TextDecoder().decode(new Uint8Array(data));
        const json = JSON.parse(jsonString);
        return json;
      } else {
        console.log("未找到隐写数据标记");
      }

      return null;
    }

    // =============================================================================
    // 数据解析模块
    // =============================================================================
    
    // 解析NovelAI的JSON数据
    function parseNovelAIData(details) {
      const result = {
        basic: [],
        prompts: [],
        technical: [],
      };

      // 主Prompt
      if (details.prompt) {
        result.prompts.push({
          label: "主Prompt",
          value: details.prompt,
          copyable: true,
        });
      }

      // 负面Prompt
      if (details.uc) {
        result.prompts.push({
          label: "负面Prompt",
          value: details.uc,
          copyable: true,
        });
      }

      // V4 角色Prompts - 按照角色顺序显示
      const charPrompts = [];
      const charNegativePrompts = [];

      if (details.v4_prompt && details.v4_prompt.caption && details.v4_prompt.caption.char_captions) {
        details.v4_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charPrompts[index] = {
              label: `角色${index + 1} Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      if (details.v4_negative_prompt && details.v4_negative_prompt.caption && details.v4_negative_prompt.caption.char_captions) {
        details.v4_negative_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charNegativePrompts[index] = {
              label: `角色${index + 1} 负面Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      // 按照角色顺序添加Prompt和负面Prompt
      const maxCharIndex = Math.max(charPrompts.length, charNegativePrompts.length);
      for (let i = 0; i < maxCharIndex; i++) {
        if (charPrompts[i]) {
          result.prompts.push(charPrompts[i]);
        }
        if (charNegativePrompts[i]) {
          result.prompts.push(charNegativePrompts[i]);
        }
      }

      // 技术参数
      result.technical.push({
        label: "采样器",
        value: details.sampler || "Unknown",
      });
      result.technical.push({
        label: "步数",
        value: details.steps || "Unknown",
      });
      result.technical.push({
        label: "尺寸",
        value: `${details.width || "?"} × ${details.height || "?"}`,
      });
      result.technical.push({
        label: "CFG Scale",
        value: details.scale || "Unknown",
      });
      result.technical.push({
        label: "种子",
        value: details.seed || "Unknown",
      });
      if (details.noise_schedule) {
        result.technical.push({
          label: "噪声计划",
          value: details.noise_schedule,
        });
      }
      if (details.cfg_rescale !== undefined) {
        result.technical.push({
          label: "CFG Rescale",
          value: details.cfg_rescale,
        });
      }
      if (details.strength !== undefined) {
        result.technical.push({
          label: "Strength",
          value: details.strength,
        });
      }
      if (details.noise !== undefined) {
        result.technical.push({
          label: "Noise",
          value: details.noise,
        });
      }
      if (details.generation_time !== undefined) {
        result.technical.push({
          label: "生成时间",
          value: `${details.generation_time.toFixed(4)}s`,
        });
      }
      if (details.request_type) {
        result.technical.push({
          label: "请求类型",
          value: details.request_type,
          wide: true,
        });
      }

      return result;
    }

    // 处理WebUI格式
    function parseWebUIData(text) {
      const result = {
        prompts: [],
        technical: [],
      };

      const parts = text.split("Steps: ");
      if (parts.length >= 2) {
        const promptPart = parts[0];
        const paramsPart = "Steps: " + parts[1];

        const promptSplit = promptPart.split("Negative prompt: ");

        result.prompts.push({
          label: "正面提示词",
          value: promptSplit[0].trim(),
          copyable: true,
        });

        if (promptSplit.length > 1) {
          result.prompts.push({
            label: "负面提示词",
            value: promptSplit[1].trim(),
            copyable: true,
          });
        }

        // 解析参数
        const params = paramsPart.match(/(\w+[\s\w]*): ([^,]+)/g);
        if (params) {
          params.forEach((param) => {
            const [key, value] = param.split(": ");
            result.technical.push({
              label: key,
              value: value,
            });
          });
        }
      }

      return result;
    }

    // 处理WebUI格式数据
    function handleWebUiTag(data) {
      let [prompts, otherParas] = data.text.split("Steps: ");
      let promptSplit = prompts.split("Negative prompt: ");
      let negativePrompt = promptSplit.length > 1 ? promptSplit[1] : "无";
      return [
        {
          label: "提示词",
          value: promptSplit[0],
          copyable: true,
        },
        {
          label: "负面提示词",
          value: negativePrompt,
          copyable: true,
        },
        {
          label: "其他参数",
          value: "Steps: " + otherParas,
          copyable: true,
        },
      ];
    }

    // =============================================================================
    // UI渲染模块
    // =============================================================================
    
    // 渲染技术参数到左侧
    function renderTechnicalParams(technicalData) {
      const technicalPanel = document.getElementById("technicalPanel");
      const technicalParams = document.getElementById("technicalParams");

      if (technicalData && technicalData.length > 0) {
        technicalParams.innerHTML = "";

        technicalData.forEach((item) => {
          const paramEl = document.createElement("div");
          paramEl.className = "tech-param-item";
          if (item.wide) {
            paramEl.classList.add("wide");
          }

          const labelEl = document.createElement("div");
          labelEl.className = "tech-param-label";
          labelEl.textContent = item.label;

          const valueEl = document.createElement("div");
          valueEl.className = "tech-param-value";
          valueEl.textContent = item.value.toString();

          // 添加点击复制功能
          paramEl.addEventListener("click", () => {
            copyToClipboard(item.value.toString());
          });

          paramEl.appendChild(labelEl);
          paramEl.appendChild(valueEl);
          technicalParams.appendChild(paramEl);
        });

        technicalPanel.style.display = "block";
      } else {
        technicalPanel.style.display = "none";
      }
    }

    // 渲染信息到右侧（不包括技术参数）
    function renderInfo(data) {
      const container = document.getElementById("infoContainer");
      container.innerHTML = "";

      // Prompts - 过滤掉不需要的字段
      if (data.prompts && data.prompts.length > 0) {
        const filteredPrompts = data.prompts.filter((item) => {
          if (!item || (!item.label && !item.key)) {
            return false; // 过滤掉无效的项目
          }
          const label = (item.label || item.key).toLowerCase();
          return !label.includes("title") && !label.includes("description") && !label.includes("基础caption") && !label.includes("负面基础caption") && !label.includes("generation_time");
        });

        if (filteredPrompts.length > 0) {
          const section = createSection("Prompts", "✨", filteredPrompts);
          container.appendChild(section);
          
          // 如果启用了翻译，开始翻译prompt
          if (SettingsManager.isTranslationEnabled() && SettingsManager.hasValidCurrentProviderConfig()) {
            translatePrompts(filteredPrompts);
          }
        }
      }

      // EXIF信息
      if (data.exif && data.exif.length > 0) {
        const section = createSection("EXIF信息", "📷", data.exif);
        container.appendChild(section);
      }
    }

    // 异步翻译prompt函数
    async function translatePrompts(promptsArray) {
      // 只翻译prompt类型的内容
      const promptsToTranslate = promptsArray.filter(item => {
        const label = (item.label || item.key || '').toLowerCase();
        return label.includes('prompt') || label.includes('caption') || label === 'description';
      });

      if (promptsToTranslate.length === 0) return;

      // 显示翻译加载状态
      promptsToTranslate.forEach((item, index) => {
        const promptContainer = document.querySelector(`[data-prompt-index="${index}"]`);
        if (promptContainer) {
          const translationContainer = promptContainer.querySelector('.prompt-translation');
          if (translationContainer) {
            translationContainer.style.display = 'block';
            translationContainer.innerHTML = '<div class="translation-loading"><span class="spinner"></span>正在翻译...</div>';
          }
        }
      });

      // 为每个prompt单独翻译
      for (let index = 0; index < promptsToTranslate.length; index++) {
        const item = promptsToTranslate[index];
        const promptContainer = document.querySelector(`[data-prompt-index="${index}"]`);
        
        if (!promptContainer) continue;
        
        const translationContainer = promptContainer.querySelector('.prompt-translation');
        if (!translationContainer) continue;

        try {
          // 提取tags
          const tags = extractTextTags(item.value);
          
          if (tags.length === 0) {
            translationContainer.innerHTML = '<div class="translation-error">无可翻译的标签</div>';
            continue;
          }

          // 翻译tags
          const translations = await TranslationManager.translate(tags);
          
          if (translations.length > 0) {
            // 渲染翻译结果
            const translatedHtml = renderTranslatedTags(translations);
            translationContainer.innerHTML = `${translatedHtml}`;
            
            // 添加悬停效果
            addHoverEffects(promptContainer);
          } else {
            translationContainer.innerHTML = '<div class="translation-error">翻译失败</div>';
          }
          
        } catch (error) {
          console.error(`翻译第${index + 1}个prompt失败:`, error);
          translationContainer.innerHTML = '<div class="translation-error">翻译失败</div>';
        }
      }
    }

    // 添加悬停效果
    function addHoverEffects(promptContainer) {
      const originalTags = promptContainer.querySelectorAll('.prompt-tag[data-tag-index]');
      const translationTags = promptContainer.querySelectorAll('.translation-tag[data-tag-index]');

      // 为原始tags添加悬停效果
      originalTags.forEach(originalTag => {
        const tagIndex = originalTag.dataset.tagIndex;
        const correspondingTranslation = promptContainer.querySelector(`.translation-tag[data-tag-index="${tagIndex}"]`);
        
        originalTag.addEventListener('mouseenter', () => {
          originalTag.classList.add('highlighted');
          if (correspondingTranslation) {
            correspondingTranslation.classList.add('highlighted');
          }
        });
        
        originalTag.addEventListener('mouseleave', () => {
          originalTag.classList.remove('highlighted');
          if (correspondingTranslation) {
            correspondingTranslation.classList.remove('highlighted');
          }
        });
      });

      // 为翻译tags添加悬停效果
      translationTags.forEach(translationTag => {
        const tagIndex = translationTag.dataset.tagIndex;
        const correspondingOriginal = promptContainer.querySelector(`.prompt-tag[data-tag-index="${tagIndex}"]`);
        
        translationTag.addEventListener('mouseenter', () => {
          translationTag.classList.add('highlighted');
          if (correspondingOriginal) {
            correspondingOriginal.classList.add('highlighted');
          }
        });
        
        translationTag.addEventListener('mouseleave', () => {
          translationTag.classList.remove('highlighted');
          if (correspondingOriginal) {
            correspondingOriginal.classList.remove('highlighted');
          }
        });
      });
    }

    function createSection(title, icon, items) {
      const section = document.createElement("div");
      section.className = "info-section";

      const titleEl = document.createElement("h2");
      titleEl.className = "section-title";
      titleEl.innerHTML = `<span class="section-icon">${icon}</span>${title}`;
      section.appendChild(titleEl);

      items.forEach((item, index) => {
        // 跳过无效的项目
        if (!item || (!item.label && !item.key) || item.value === undefined || item.value === null) {
          console.warn("跳过无效项目:", item);
          return;
        }

        const itemEl = document.createElement("div");
        itemEl.className = "info-item";
        itemEl.style.animationDelay = `${index * CONFIG.UI.ANIMATION_DELAY_STEP}s`;

        const labelEl = document.createElement("div");
        labelEl.className = "info-label";

        const labelText = document.createElement("span");
        const itemLabel = item.label || item.key || "未知字段";
        labelText.textContent = itemLabel;
        labelEl.appendChild(labelText);

        // 检查是否为prompt相关内容
        const labelToCheck = itemLabel.toLowerCase();
        const isPrompt = labelToCheck.includes("prompt") || labelToCheck.includes("caption") || labelToCheck === "description";

        if (item.copyable) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.textContent = "复制";

          // 对于prompt类型，复制格式化后的文本；对于其他类型，复制原始文本
          if (isPrompt && item.value && typeof item.value === "string") {
            const formattedText = formatPrompt(item.value);
            copyBtn.onclick = () => copyToClipboard(formattedText);
          } else {
            copyBtn.onclick = () => copyToClipboard(item.value);
          }

          labelEl.appendChild(copyBtn);
        }

        itemEl.appendChild(labelEl);

        const valueEl = document.createElement("div");
        valueEl.className = "info-value";

        if (isPrompt && item.value && typeof item.value === "string") {
          // 判断是否为负面prompt
          const isNegativePrompt = labelToCheck.includes("负面") || labelToCheck.includes("negative");

          // 创建prompt容器
          const promptContainer = document.createElement("div");
          promptContainer.className = "prompt-container";
          
          // 对prompt内容进行格式化和高亮
          valueEl.classList.add("formatted-prompt");
          valueEl.innerHTML = renderHighlightedPrompt(item.value, isNegativePrompt);
          
          promptContainer.appendChild(valueEl);
          
          // 创建翻译容器
          const translationContainer = document.createElement("div");
          translationContainer.className = "prompt-translation";
          translationContainer.style.display = "none";
          promptContainer.appendChild(translationContainer);
          
          itemEl.appendChild(promptContainer);
          
          // 存储prompt信息用于翻译
          promptContainer.dataset.promptIndex = index;
          promptContainer.dataset.promptValue = item.value;
        } else {
          // 普通文本内容
          valueEl.textContent = item.value;
          itemEl.appendChild(valueEl);
        }

        section.appendChild(itemEl);
      });

      return section;
    }

    // =============================================================================
    // 图片预览和状态管理模块
    // =============================================================================
    
    // 应用状态管理
    const AppState = {
      currentFile: null,
      
      setCurrentFile(file) {
        this.currentFile = file;
      },
      
      getCurrentFile() {
        return this.currentFile;
      },
      
      clearCurrentFile() {
        this.currentFile = null;
      }
    };

    // 显示图片预览和基本信息
    function showImagePreview(file, modelInfo = null) {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const imageFilename = document.getElementById("imageFilename");
      const imageDetails = document.getElementById("imageDetails");

      // 读取图片并显示预览
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewImage.style.display = "block";

        // 隐藏上传提示，显示图片信息
        uploadContent.style.display = "none";
        uploadArea.classList.add("has-image");

        // 显示文件信息
        // 计算可用宽度，大约是容器宽度减去padding
        const displayFilename = truncateFilename(file.name, CONFIG.UI.FILENAME_MAX_WIDTH);
        imageFilename.textContent = displayFilename;
        imageFilename.title = file.name; // 鼠标悬停显示完整文件名

        // 添加点击复制完整文件名功能
        imageFilename.onclick = () => {
          copyToClipboard(file.name);
        };

        // 构建详细信息，如果有模型信息就显示模型，否则显示文件类型
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">大小:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">${modelInfo ? "模型:" : "类型:"}</span>
                        <span class="detail-value">${modelInfo || file.type}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
        imageInfo.style.display = "block";
      };
      reader.readAsDataURL(file);
    }

    // 更新图片信息中的模型显示
    function updateImageModelInfo(modelInfo) {
      const imageDetails = document.getElementById("imageDetails");
      const file = AppState.getCurrentFile();

      if (imageDetails && modelInfo && file) {
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">大小:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">模型:</span>
                        <span class="detail-value">${modelInfo}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
      }
    }

    // 重置界面的函数
    function resetInterface() {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const technicalPanel = document.getElementById("technicalPanel");
      const rightPanel = document.getElementById("rightPanel");
      
      uploadArea.classList.remove("has-image");
      uploadContent.style.display = "flex";
      previewImage.style.display = "none";
      imageInfo.style.display = "none";
      technicalPanel.style.display = "none";
      rightPanel.style.display = "none";
      AppState.clearCurrentFile();

      // 清除文件名的点击事件
      const imageFilename = document.getElementById("imageFilename");
      if (imageFilename) {
        imageFilename.onclick = null;
        imageFilename.title = "";
      }
    }

    // =============================================================================
    // 主要处理流程
    // =============================================================================
    
         // 处理隐写术数据
     async function processStealthExif(imageSrc) {
       console.log("尝试隐写术提取...");
       const exif = await getStealthExif(imageSrc);
       
       if (!exif) {
         return {
           metaType: CONFIG.METADATA_TYPES.UNKNOWN,
           promptsData: [{
             label: "提示",
             value: "😭 无法读取到图像 Metadata，这可能不是一张 Stable Diffusion 生成的图。或者不是原图, 经过了压缩。",
             copyable: false,
           }],
           stealthExifData: null
         };
       }

      console.log("隐写术提取成功:", exif);
      const promptsData = [];

      // 处理隐写术数据
      for (const [key, value] of Object.entries(exif)) {
        if (key === "Comment") {
          // Comment包含完整的JSON数据，需要解析
          try {
            const jsonData = JSON.parse(value);
            console.log("隐写术Comment JSON data:", jsonData);
            const novelAIData = parseNovelAIData(jsonData);
            promptsData.push(...novelAIData.prompts);
            // 设置技术参数
            renderTechnicalParams(novelAIData.technical);
          } catch (e) {
            console.error("解析隐写术Comment JSON失败:", e);
            promptsData.push({
              label: "Comment",
              value: value,
              copyable: true,
            });
          }
        } else if (key === "Description") {
          // Description通常是主prompt
          promptsData.push({
            label: "主Prompt (Description)",
            value: value,
            copyable: true,
          });
        }
      }

      // 更新图片显示中的模型信息
      if (exif.Source) {
        updateImageModelInfo(exif.Source);
      }

             return {
         metaType: CONFIG.METADATA_TYPES.NOVELAI,
         promptsData,
         stealthExifData: exif
       };
    }

         // 处理PNG文本块数据
     function processPngTextChunks(metadata) {
       const promptsData = [];
       let metaType = CONFIG.METADATA_TYPES.SD_WEBUI;

      if (metadata.length === 1 && metadata[0].keyword === "parameters") {
        // SD WebUI 格式
        const webUIData = handleWebUiTag(metadata[0]);
        promptsData.push(...webUIData);
        renderTechnicalParams([]);
      } else {
        // 处理PNG文本块中的NovelAI Comment格式
        for (const meta of metadata) {
          if (meta.keyword === "Comment") {
            try {
              const jsonData = JSON.parse(meta.text);
              console.log("PNG文本块 NovelAI JSON data:", jsonData);
              const novelAIData = parseNovelAIData(jsonData);
              promptsData.push(...novelAIData.prompts);
              // 设置技术参数
              renderTechnicalParams(novelAIData.technical);
              metaType = CONFIG.METADATA_TYPES.NOVELAI;
            } catch (e) {
              console.error("解析PNG文本块Comment JSON失败:", e);
              promptsData.push({
                label: meta.keyword,
                value: meta.text,
                copyable: true,
              });
            }
          } else if (meta.keyword === "Source") {
            // 更新模型信息显示
            if (meta.text) {
              updateImageModelInfo(meta.text);
            }
          } else if (meta.keyword === "Description") {
            promptsData.push({
              label: "主Prompt (Description)",
              value: meta.text,
              copyable: true,
            });
          } else if (meta.keyword !== "Software" && meta.keyword !== "Generation time") {
            // 其他非基础信息的字段作为prompt处理
            promptsData.push({
              label: meta.keyword,
              value: meta.text,
              copyable: true,
            });
          }
        }
      }

      return { metaType, promptsData };
    }

    // 构建基础信息
    function buildBasicInfo(file, metaType, stealthExifData) {
      const basicInfo = [
        { label: "文件名", value: file.name },
        { label: "文件大小", value: formatFileSize(file.size) },
      ];

             // 如果有模型信息，添加到基础信息中
       if (metaType === CONFIG.METADATA_TYPES.NOVELAI && stealthExifData) {
        if (stealthExifData.Software) {
          basicInfo.push({ label: "软件", value: stealthExifData.Software });
        }
        if (stealthExifData.Source) {
          basicInfo.push({ label: "模型", value: stealthExifData.Source });
        }
        if (stealthExifData["Generation time"]) {
          basicInfo.push({ label: "生成时间", value: stealthExifData["Generation time"] + "s" });
        }
      }

      return basicInfo;
    }

    // 处理图片主函数
    async function processImage(file) {
      const rightPanel = document.getElementById("rightPanel");

      // 保存当前文件引用用于后续更新
      AppState.setCurrentFile(file);

      // 显示图片预览
      showImagePreview(file);

      // 读取图片作为DataURL用于隐写术提取
      const reader = new FileReader();
      reader.onload = async (e) => {
        const imageSrc = e.target.result;

        try {
          // 提取元数据
          const metadata = await extractMetadata(file);
          console.log("提取的元数据:", metadata);

          let metaType, promptsData, stealthExifData = null;

          if (metadata.length === 0) {
            // 尝试隐写术提取
            const stealthResult = await processStealthExif(imageSrc);
            metaType = stealthResult.metaType;
            promptsData = stealthResult.promptsData;
            stealthExifData = stealthResult.stealthExifData;
          } else {
            // 处理PNG文本块
            const pngResult = processPngTextChunks(metadata);
            metaType = pngResult.metaType;
            promptsData = pngResult.promptsData;
          }

          // 构建完整数据结构
          const basicInfo = buildBasicInfo(file, metaType, stealthExifData);
          const allData = {
            basic: basicInfo,
            prompts: promptsData,
            technical: [],
            exif: [],
          };

                     // 添加SD-WEBUI完整信息
           if (metaType === CONFIG.METADATA_TYPES.SD_WEBUI && metadata.length > 0) {
            allData.prompts.push({
              key: "完整生成信息",
              value: metadata[0]["text"],
              copyable: true,
            });
          }

                     // 如果不是NovelAI格式，渲染空的技术参数
           if (metaType !== CONFIG.METADATA_TYPES.NOVELAI) {
            renderTechnicalParams([]);
          }

          // 渲染信息到右侧
          renderInfo(allData);
          rightPanel.style.display = "block";

                 } catch (error) {
           ErrorHandler.handleProcessingError(error, "处理图片");
         }
      };

      reader.readAsDataURL(file);
    }

    // =============================================================================
    // 初始化和事件绑定
    // =============================================================================
    
    // =============================================================================
    // 设置面板功能
    // =============================================================================
    
    function initializeSettings() {
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsModal = document.getElementById('settingsModal');
      const closeSettingsBtn = document.getElementById('closeSettingsBtn');
      
      // 所有输入元素
      const translationToggle = document.getElementById('translationToggle');
      const translationProviderSelect = document.getElementById('translationProviderSelect');
      
      // Gemini 配置
      const apiKeyInput = document.getElementById('apiKeyInput');
      
      // 腾讯云配置
      const tencentSecretIdInput = document.getElementById('tencentSecretIdInput');
      const tencentSecretKeyInput = document.getElementById('tencentSecretKeyInput');
      
      // 百度翻译配置
      const baiduAppIdInput = document.getElementById('baiduAppIdInput');
      const baiduAppKeyInput = document.getElementById('baiduAppKeyInput');
      
      // 按钮
      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      const testConnectionBtn = document.getElementById('testConnectionBtn');

      // 显示/隐藏配置区域
      function showProviderConfig(provider) {
        const configs = ['geminiConfig', 'tencentConfig', 'baiduConfig'];
        configs.forEach(configId => {
          const config = document.getElementById(configId);
          if (config) {
            config.style.display = configId === `${provider}Config` ? 'block' : 'none';
          }
        });
      }

      // 加载设置
      function loadSettings() {
        // 翻译开关
        if (SettingsManager.isTranslationEnabled()) {
          translationToggle.classList.add('active');
        } else {
          translationToggle.classList.remove('active');
        }

        // 翻译服务提供商
        const provider = SettingsManager.getTranslationProvider();
        translationProviderSelect.value = provider;
        showProviderConfig(provider);

        // Gemini 配置
        apiKeyInput.value = SettingsManager.getApiKey();

        // 腾讯云配置
        tencentSecretIdInput.value = SettingsManager.getTencentSecretId();
        tencentSecretKeyInput.value = SettingsManager.getTencentSecretKey();

        // 百度翻译配置
        baiduAppIdInput.value = SettingsManager.getBaiduAppId();
        baiduAppKeyInput.value = SettingsManager.getBaiduAppKey();
      }

      // 保存设置
      function saveSettings() {
        const translationEnabled = translationToggle.classList.contains('active');
        const provider = translationProviderSelect.value;

        // 保存基本设置
        SettingsManager.setTranslationEnabled(translationEnabled);
        SettingsManager.setTranslationProvider(provider);

        // 保存API密钥配置
        SettingsManager.setApiKey(apiKeyInput.value.trim());
        SettingsManager.setTencentSecretId(tencentSecretIdInput.value.trim());
        SettingsManager.setTencentSecretKey(tencentSecretKeyInput.value.trim());
        SettingsManager.setBaiduAppId(baiduAppIdInput.value.trim());
        SettingsManager.setBaiduAppKey(baiduAppKeyInput.value.trim());

        showToast('设置已保存');
        closeSettings();
      }

      // 显示测试结果
      function showTestResult(type, message) {
        const testResult = document.getElementById('testResult');
        const testResultContent = document.getElementById('testResultContent');
        
        testResult.className = `test-result ${type}`;
        testResultContent.innerHTML = message;
        testResult.style.display = 'block';
      }

      // 隐藏测试结果
      function hideTestResult() {
        const testResult = document.getElementById('testResult');
        testResult.style.display = 'none';
      }

      // 测试连接
      async function testConnection() {
        const provider = translationProviderSelect.value;
        testConnectionBtn.disabled = true;
        testConnectionBtn.textContent = '测试中...';
        
        // 显示测试中状态
        showTestResult('loading', '🔄 正在测试连接，请稍候...');

        try {
          // 检查配置
          let hasValidConfig = false;
          let configError = '';
          
          switch (provider) {
            case 'gemini':
              hasValidConfig = apiKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = '请填写 Gemini API Key';
              break;
            case 'tencent':
              hasValidConfig = tencentSecretIdInput.value.trim().length > 0 && 
                              tencentSecretKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = '请填写腾讯云 Secret ID 和 Secret Key';
              break;
            case 'baidu':
              hasValidConfig = baiduAppIdInput.value.trim().length > 0 && 
                              baiduAppKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = '请填写百度翻译 App ID 和 App Key';
              break;
          }

          if (!hasValidConfig) {
            throw new Error(configError);
          }

          // 临时保存配置
          const originalProvider = SettingsManager.getTranslationProvider();
          const originalConfigs = {};
          
          // 备份原始配置
          originalConfigs.geminiKey = SettingsManager.getApiKey();
          originalConfigs.tencentId = SettingsManager.getTencentSecretId();
          originalConfigs.tencentKey = SettingsManager.getTencentSecretKey();
          originalConfigs.baiduId = SettingsManager.getBaiduAppId();
          originalConfigs.baiduKey = SettingsManager.getBaiduAppKey();

          // 设置测试配置
          SettingsManager.setTranslationProvider(provider);
          SettingsManager.setApiKey(apiKeyInput.value.trim());
          SettingsManager.setTencentSecretId(tencentSecretIdInput.value.trim());
          SettingsManager.setTencentSecretKey(tencentSecretKeyInput.value.trim());
          SettingsManager.setBaiduAppId(baiduAppIdInput.value.trim());
          SettingsManager.setBaiduAppKey(baiduAppKeyInput.value.trim());

          // 测试翻译（不使用缓存，直接测试API）
          const testTags = ['test'];
          const result = await TranslationManager.translateTags(testTags, provider);

          if (result && result.length > 0) {
            showTestResult('success', `✅ <strong>${provider}</strong> 连接测试成功！<br>翻译结果：<strong>${result[0]}</strong>`);
          } else {
            throw new Error('翻译返回结果为空');
          }

          // 恢复原始配置
          SettingsManager.setTranslationProvider(originalProvider);
          SettingsManager.setApiKey(originalConfigs.geminiKey);
          SettingsManager.setTencentSecretId(originalConfigs.tencentId);
          SettingsManager.setTencentSecretKey(originalConfigs.tencentKey);
          SettingsManager.setBaiduAppId(originalConfigs.baiduId);
          SettingsManager.setBaiduAppKey(originalConfigs.baiduKey);

        } catch (error) {
          console.error('连接测试失败:', error);
          let errorMessage = error.message;
          
          // 针对不同错误类型提供特殊提示
          if (errorMessage.includes('CORS') || errorMessage.includes('网络') || 
              errorMessage.includes('Failed to fetch') || errorMessage.includes('Access to fetch')) {
            if (provider === 'tencent' || provider === 'baidu') {
              errorMessage = `❌ <strong>${provider}</strong> 连接失败<br><br>
                <strong>CORS 跨域错误</strong><br>
                💡 请安装以下任一解决方案：<br>
                • Chrome 插件：CORS Unblock<br>
                • Tampermonkey 脚本：novelai-translator-cors.user.js<br>
                • 详见配置指南文档`;
            }
          } else if (errorMessage.includes('Invalid Sign') || errorMessage.includes('54001')) {
            errorMessage = `❌ <strong>${provider}</strong> 签名错误<br><br>
              <strong>可能的原因：</strong><br>
              • API 密钥不正确<br>
              • App ID 或 App Key 输入错误<br>
              • 请检查配置信息是否完整`;
          } else if (errorMessage.includes('API')) {
            errorMessage = `❌ <strong>${provider}</strong> API 错误<br><br>
              <strong>错误信息：</strong> ${errorMessage}`;
          } else {
            errorMessage = `❌ <strong>${provider}</strong> 连接失败<br><br>
              <strong>错误信息：</strong> ${errorMessage}`;
          }
          
          showTestResult('error', errorMessage);
        } finally {
          testConnectionBtn.disabled = false;
          testConnectionBtn.textContent = '测试连接';
        }
      }

      // 打开设置面板
      function openSettings() {
        loadSettings();
        settingsModal.classList.add('show');
      }

      // 关闭设置面板
      function closeSettings() {
        settingsModal.classList.remove('show');
      }

      // 事件绑定
      settingsBtn.addEventListener('click', openSettings);
      closeSettingsBtn.addEventListener('click', closeSettings);
      
      // 点击模态框背景关闭
      settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
          closeSettings();
        }
      });

      // 翻译服务提供商切换
      translationProviderSelect.addEventListener('change', (e) => {
        showProviderConfig(e.target.value);
        hideTestResult(); // 切换服务时隐藏之前的测试结果
      });

      // 切换开关
      translationToggle.addEventListener('click', () => {
        translationToggle.classList.toggle('active');
      });

      // 保存按钮
      saveSettingsBtn.addEventListener('click', saveSettings);

      // 测试连接按钮
      testConnectionBtn.addEventListener('click', testConnection);

      // ESC键关闭
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsModal.classList.contains('show')) {
          closeSettings();
        }
      });

      // 初始加载设置
      loadSettings();
    }

    // 初始化上传功能
    document.addEventListener("DOMContentLoaded", () => {
      // 初始化设置功能
      initializeSettings();
      
      // 预加载翻译缓存（无论是否开启翻译，都预加载以提高性能）
      TranslationManager.loadLocalCache();
      
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");

      uploadArea.addEventListener("click", (e) => {
        // 如果点击的是图片，询问是否要选择新图片
        if (e.target.tagName === "IMG" && e.target.id === "previewImage") {
          if (confirm("要选择新的图片吗？")) {
            resetInterface();
            fileInput.click();
          }
        } else if (!uploadArea.classList.contains("has-image")) {
          // 如果还没有图片，直接打开选择
          fileInput.click();
        }
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
        // 清空input，允许重复选择同一文件
        fileInput.value = "";
      });

      // 拖拽功能
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("drag-over");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("drag-over");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("drag-over");

        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
      });
    });
  </script>
</body>

</html>