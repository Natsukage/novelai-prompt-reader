<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NovelAI å›¾ç‰‡è§£æ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .main-content {
      display: grid;
      grid-template-columns: 2fr 3fr;
      gap: 30px;
      align-items: start;
    }

    @media (max-width: 968px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .left-column {
        margin-bottom: 0;
      }

      .technical-panel {
        margin-bottom: 0;
      }

      .right-panel {
        margin-top: 0;
      }
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .left-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .technical-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .upload-area {
      border: 3px dashed #e0e6ed;
      border-radius: 12px;
      padding: 60px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #f8f9fc;
      width: 100%;
      min-height: 350px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .upload-area:hover {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .upload-area.drag-over {
      border-color: #667eea;
      background: #e8ebff;
      transform: scale(1.02);
    }

    .upload-area.has-image {
      padding: 20px;
      background: #fff;
      cursor: default;
      min-height: auto;
      border-color: #d0d7de;
    }

    .upload-area.has-image:hover {
      background: #f8f9fc;
      border-color: #667eea;
    }

    .upload-area.has-image .preview-image {
      cursor: pointer;
    }

    .image-info-compact {
      text-align: center;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e8ebf4;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      width: 100%;
    }

    .image-info-compact .image-filename {
      font-size: 0.95rem;
      color: #333;
      font-weight: 500;
      margin-bottom: 5px;
      white-space: nowrap;
      overflow: hidden;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .image-info-compact .image-filename:hover {
      color: #667eea;
    }

    .image-info-compact .image-details {
      font-size: 0.85rem;
      color: #666;
      cursor: help;
    }

    .section-icon {
      color: #667eea;
    }

    #uploadContent {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .upload-icon {
      font-size: 48px;
      color: #667eea;
      margin-bottom: 20px;
    }

    .upload-text {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 10px;
    }

    .upload-hint {
      color: #999;
      font-size: 0.9rem;
    }

    .preview-image {
      max-width: 100%;
      max-height: 350px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: block;
      margin: 0 auto;
      cursor: pointer;
    }

    .preview-image:hover {
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
    }

    .image-filename {
      font-size: 1.1rem;
      font-weight: 500;
      color: #333;
      margin-bottom: 10px;
      word-break: break-all;
    }

    .image-details {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: #666;
    }

    .detail-label {
      color: #999;
    }

    .detail-value {
      color: #333;
      font-weight: 500;
    }

    .right-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      max-height: 90vh;
      overflow-y: auto;
    }

    .info-section {
      margin-bottom: 30px;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #444;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-item {
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      border: 1px solid #e8ebf4;
      transition: all 0.3s ease;
    }

    .info-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .info-label {
      font-weight: 600;
      color: #555;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .info-value {
      color: #666;
      line-height: 1.6;
      word-break: break-word;
      white-space: pre-wrap;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.9rem;
    }

    .info-value.formatted-prompt {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 0.95rem;
      line-height: 1.7;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    /* Promptæƒé‡é«˜äº®æ ·å¼ */
    .prompt-tag {
      display: inline;
    }

    .prompt-tag.weight-high {
      color: #e53e3e;
    }

    .prompt-tag.weight-low {
      color: #3182ce;
    }

    .prompt-tag.weight-normal {
      color: #333;
    }

    .prompt-tag.default-tag {
      color: #a0aec0;
      opacity: 0.7;
    }

    .prompt-weight-marker {
      color: #805ad5;
      font-weight: 600;
      opacity: 0.8;
      white-space: nowrap;
    }

    .prompt-comma {
      color: #a0aec0;
    }

    .tech-params {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e8ebf4;
    }

    @media (max-width: 768px) {
      .tech-params {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 12px;
        padding: 15px;
      }
    }

    .tech-param-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      padding: 8px;
      border-radius: 6px;
      overflow-wrap: break-word;
    }

    .tech-param-item:hover {
      background-color: rgba(102, 126, 234, 0.1);
    }

    .tech-param-item.wide {
      grid-column: span 2;
    }

    .tech-param-label {
      font-size: 0.85rem;
      color: #888;
      font-weight: 500;
    }

    .tech-param-value {
      font-size: 0.95rem;
      color: #333;
      font-weight: 600;
      font-family: "Monaco", "Consolas", monospace;
    }

    .copy-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
    }

    .copy-btn:hover {
      background: #5a67d8;
      transform: translateY(-1px);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .json-viewer {
      background: #f5f7fa;
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.85rem;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #999;
    }

    .error {
      background: #fee;
      color: #c33;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }

    .footer {
      text-align: center;
      margin-top: 50px;
      padding: 20px;
      color: #999;
      font-size: 0.9rem;
      clear: both;
    }

    .footer a {
      color: #667eea;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* æ»šåŠ¨æ¡æ ·å¼ */
    .right-panel::-webkit-scrollbar {
      width: 8px;
    }

    .right-panel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* åŠ¨ç”» */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .info-item {
      animation: fadeIn 0.5s ease;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #667eea;
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ¨ NovelAI å›¾ç‰‡è§£æ</h1>
      <p>ä» NovelAI ç”Ÿæˆçš„å›¾ç‰‡ä¸­æå–è¯¦ç»†å‚æ•°ä¿¡æ¯</p>
    </div>

    <div class="main-content">
      <div class="left-column">
        <div class="left-panel">
          <div class="upload-area" id="uploadArea">
            <div id="uploadContent">
              <div class="upload-icon">ğŸ“</div>
              <div class="upload-text">æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ</div>
              <div class="upload-hint">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
            </div>
            <!-- é¢„è§ˆå›¾ç‰‡ -->
            <img id="previewImage" class="preview-image" style="display: none" alt="é¢„è§ˆå›¾ç‰‡" />
            <!-- åŸºç¡€ä¿¡æ¯ -->
            <div class="image-info-compact" id="imageInfo" style="display: none">
              <div class="image-filename" id="imageFilename"></div>
              <div class="image-details" id="imageDetails"></div>
            </div>
            <input type="file" id="fileInput" accept="image/*" style="display: none" />
          </div>
        </div>

        <!-- æŠ€æœ¯å‚æ•°åŒºåŸŸ -->
        <div class="technical-panel" id="technicalPanel" style="display: none">
          <div id="technicalParams" class="tech-params"></div>
        </div>
      </div>

      <div class="right-panel" id="rightPanel" style="display: none">
        <div id="infoContainer"></div>
      </div>
    </div>

    <div class="footer">
      <p>* æ‰€æœ‰è¿ç®—å®Œå…¨åœ¨æ‚¨çš„è®¾å¤‡ä¸Šè¿è¡Œï¼Œä¸ä¼šä¸Šä¼ åˆ°äº‘ç«¯</p>
      <p>Made by <a href="https://github.com/Natsukage">@Natsukage</a></p>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- å¼•å…¥å¿…è¦çš„åº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    // =============================================================================
    // å·¥å…·å‡½æ•°æ¨¡å—
    // =============================================================================
    
    // DOMå·¥å…·å‡½æ•°
    const DOMUtils = {
      getElementById(id) {
        const element = document.getElementById(id);
        if (!element) {
          console.warn(`Element with id '${id}' not found`);
        }
        return element;
      },

      toggleElementDisplay(elementId, show) {
        const element = this.getElementById(elementId);
        if (element) {
          element.style.display = show ? "block" : "none";
        }
      },

      setElementContent(elementId, content) {
        const element = this.getElementById(elementId);
        if (element) {
          element.innerHTML = content;
        }
      }
    };

    // é”™è¯¯å¤„ç†å·¥å…·
    const ErrorHandler = {
      logError(message, error) {
        console.error(message, error);
      },

      handleProcessingError(error, context = "æœªçŸ¥æ“ä½œ") {
        this.logError(`${context}æ—¶å‡ºé”™:`, error);
        showToast(`${context}æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•`);
      }
    };

    function showToast(message) {
      const toast = DOMUtils.getElementById("toast");
      if (toast) {
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }
    }

    function copyToClipboard(text) {
      navigator.clipboard
        .writeText(text)
        .then(() => {
          showToast("å¤åˆ¶æˆåŠŸï¼");
        })
        .catch(() => {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
        });
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + " B";
      else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + " KB";
      else return (bytes / 1048576).toFixed(2) + " MB";
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // =============================================================================
    // æ–‡ä»¶å¤„ç†æ¨¡å—
    // =============================================================================
    
    // å¤„ç†æ–‡ä»¶åæ˜¾ç¤º - ä¸­é—´çœç•¥ï¼Œä¿ç•™æ‰©å±•å
    function truncateFilename(filename, maxWidth) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      context.font = '0.95rem -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

      // å¦‚æœæ–‡ä»¶åå®½åº¦å°äºæœ€å¤§å®½åº¦ï¼Œç›´æ¥è¿”å›
      if (context.measureText(filename).width <= maxWidth) {
        return filename;
      }

      // æå–æ–‡ä»¶åå’Œæ‰©å±•å
      const lastDotIndex = filename.lastIndexOf(".");
      const extension = lastDotIndex !== -1 ? filename.substring(lastDotIndex) : "";
      const nameWithoutExt = lastDotIndex !== -1 ? filename.substring(0, lastDotIndex) : filename;

      // è®¡ç®—çœç•¥å·å’Œæ‰©å±•åçš„å®½åº¦
      const ellipsisWidth = context.measureText("...").width;
      const extensionWidth = context.measureText(extension).width;

      // é¢„ç•™è‡³å°‘3ä¸ªå­—ç¬¦çš„ç©ºé—´åœ¨çœç•¥å·å‰ï¼Œé˜²æ­¢çœç•¥å·ç´§è´´æ‰©å±•å
      const minEndChars = Math.min(3, Math.floor(nameWithoutExt.length / 2));
      const endPart = nameWithoutExt.substring(nameWithoutExt.length - minEndChars);
      const endPartWidth = context.measureText(endPart).width;

      const totalEndWidth = ellipsisWidth + endPartWidth + extensionWidth;
      const availableWidth = maxWidth - totalEndWidth;

      // äºŒåˆ†æŸ¥æ‰¾åˆé€‚çš„æˆªæ–­é•¿åº¦
      let start = 0;
      let end = nameWithoutExt.length - minEndChars;
      let bestLength = 0;

      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const truncated = nameWithoutExt.substring(0, mid);
        const width = context.measureText(truncated).width;

        if (width <= availableWidth) {
          bestLength = mid;
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }

      if (bestLength === 0) {
        return "..." + endPart + extension;
      }

      return nameWithoutExt.substring(0, bestLength) + "..." + endPart + extension;
    }

    // =============================================================================
    // é…ç½®å’Œå¸¸é‡æ¨¡å—
    // =============================================================================
    
    const CONFIG = {
      // ç•Œé¢é…ç½®
      UI: {
        FILENAME_MAX_WIDTH: 250,
        TOAST_DURATION: 3000,
        ANIMATION_DELAY_STEP: 0.1
      },

      // NovelAIé…ç½®
      NOVELAI: {
        DEFAULT_POSITIVE_TAGS: ["very aesthetic", "location", "masterpiece", "no text", "feet", "rating:general"],
        DEFAULT_NEGATIVE_TAGS: [
          "blurry", "lowres", "upscaled", "artistic error", "film grain", "scan artifacts",
          "worst quality", "bad quality", "jpeg artifacts", "very displeasing", 
          "chromatic aberration", "halftone", "multiple views", "logo", 
          "too many watermarks", "negative space", "blank page",
        ],
        WEIGHT_MULTIPLIER: 1.1,
        STEGANOGRAPHY_MAGIC: "stealth_pngcomp"
      },

      // æ”¯æŒçš„æ–‡ä»¶ç±»å‹
      SUPPORTED_FILE_TYPES: ["image/png", "image/jpeg", "image/jpg"],
      
      // å…ƒæ•°æ®ç±»å‹
      METADATA_TYPES: {
        SD_WEBUI: "SD-WEBUI",
        NOVELAI: "NOVELAI", 
        UNKNOWN: "UNKNOWN"
      }
    };

    // =============================================================================
    // Promptå¤„ç†æ¨¡å—
    // =============================================================================

    // Promptæ ¼å¼åŒ–å‡½æ•°
    function formatPrompt(prompt) {
      if (!prompt || typeof prompt !== "string") return prompt;

      // 1. å»é™¤è½¬ä¹‰å­—ç¬¦
      let formatted = prompt.replace(/\\([()])/g, "$1");
      // 2. å»é™¤å¤šä½™çš„è¿ç»­é€—å·
      formatted = formatted.replace(/,{2,}/g, ",");
      // 3. æ ‡å‡†åŒ–é€—å·åçš„ç©ºæ ¼ï¼šç¡®ä¿é€—å·åæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç©ºæ ¼
      formatted = formatted.replace(/,\s*/g, ", ");
      // 4. å»é™¤å¼€å¤´å’Œç»“å°¾çš„é€—å·å’Œç©ºæ ¼
      formatted = formatted.replace(/^[\s,]+|[\s,]+$/g, "");

      return formatted;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
    function isDefaultTag(tagContent, isNegativePrompt = false) {
      const content = tagContent.toLowerCase().trim();
      const defaultTags = isNegativePrompt ? CONFIG.NOVELAI.DEFAULT_NEGATIVE_TAGS : CONFIG.NOVELAI.DEFAULT_POSITIVE_TAGS;
      return defaultTags.some((defaultTag) => content === defaultTag.toLowerCase() || content.includes(defaultTag.toLowerCase()));
    }

    // NovelAIæƒé‡è§£æå™¨
    function parsePromptWeights(prompt) {
      const tokens = [];
      let i = 0;
      let currentWeight = 1.0;
      const weightStack = [1.0]; // ç”¨äºå¤„ç†åµŒå¥—æƒé‡

      while (i < prompt.length) {
        const char = prompt[i];

        // å¤„ç†æ•°å­—æƒé‡è¯­æ³•ï¼šæ•°å­—::
        if (char.match(/[-\d]/) && prompt.substring(i).match(/^[-\d.]+::/)) {
          const match = prompt.substring(i).match(/^([-\d.]+)::/);
          if (match) {
            const weight = parseFloat(match[1]);
            tokens.push({
              type: "weight-marker",
              content: match[0],
              weight: weight,
            });
            currentWeight = weight;
            weightStack.push(weight); // æ¨å…¥æ–°æƒé‡
            i += match[0].length;
            continue;
          }
        }

        // å¤„ç†æƒé‡ç»“æŸæ ‡è®°ï¼š::
        if (prompt.substring(i, i + 2) === "::") {
          tokens.push({
            type: "weight-marker",
            content: "::",
            weight: 1.0,
          });
          // æ¢å¤åˆ°æƒé‡æ ˆçš„ä¸Šä¸€å±‚
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i += 2;
          continue;
        }

        // å¤„ç†æ—§å¼æƒé‡ï¼š{ å’Œ [
        if (char === "{") {
          const newWeight = currentWeight * CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "{",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "[") {
          const newWeight = currentWeight / CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "[",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "}" || char === "]") {
          tokens.push({
            type: "weight-marker",
            content: char,
            weight: 1.0,
          });
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i++;
          continue;
        }

        // å¤„ç†é€—å·
        if (char === ",") {
          tokens.push({
            type: "comma",
            content: char,
            weight: 1.0,
          });
          i++;
          // è·³è¿‡é€—å·åçš„ç©ºæ ¼
          while (i < prompt.length && prompt[i] === " ") {
            i++;
          }
          continue;
        }

        // è·³è¿‡å…¶ä»–ç©ºæ ¼
        if (char === " ") {
          i++;
          continue;
        }

        // å¤„ç†æ™®é€šæ–‡æœ¬
        let textContent = "";
        while (i < prompt.length) {
          const currentChar = prompt[i];
          const nextTwoChars = prompt.substring(i, i + 2);

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡æ ‡è®°çš„å¼€å§‹
          if (prompt.substring(i).match(/^[-\d.]+::/)) {
            break;
          }

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡ç»“æŸæ ‡è®°
          if (nextTwoChars === "::") {
            break;
          }

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æ‹¬å·æˆ–é€—å·
          if ("{[}],".includes(currentChar)) {
            break;
          }

          textContent += currentChar;
          i++;
        }

        if (textContent.trim()) {
          tokens.push({
            type: "text",
            content: textContent.trim(),
            weight: currentWeight,
          });
        }
      }

      return tokens;
    }

    // æ¸²æŸ“æƒé‡é«˜äº®çš„Prompt
    function renderHighlightedPrompt(prompt, isNegativePrompt = false) {
      const formatted = formatPrompt(prompt);
      const tokens = parsePromptWeights(formatted);

      let html = "";

      tokens.forEach((token, index) => {
        if (token.type === "weight-marker") {
          html += `<span class="prompt-weight-marker">${escapeHtml(token.content)}</span>`;
        } else if (token.type === "comma") {
          // åœ¨é€—å·åæ·»åŠ çœŸå®ç©ºæ ¼ï¼Œç»™æµè§ˆå™¨æ­£ç¡®çš„æ¢è¡Œä½ç½®
          html += `<span class="prompt-comma">${escapeHtml(token.content)}</span> `;
        } else if (token.type === "text" && token.content) {
          let className = "prompt-tag weight-normal";

          // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
          const isDefault = isDefaultTag(token.content, isNegativePrompt);

          if (isDefault) {
            className = "prompt-tag default-tag";
          } else if (Math.abs(token.weight) > 1.0) {
            className = "prompt-tag weight-high";
          } else if (Math.abs(token.weight) < 1.0 && token.weight !== 0) {
            className = "prompt-tag weight-low";
          }

          html += `<span class="${className}">${escapeHtml(token.content)}</span>`;

          // åœ¨æ–‡æœ¬tokenåæ·»åŠ ç©ºæ ¼ï¼Œé™¤éä¸‹ä¸€ä¸ªtokenæ˜¯é€—å·æˆ–æƒé‡æ ‡è®°
          if (index < tokens.length - 1) {
            const nextToken = tokens[index + 1];
            if (nextToken.type !== "comma" && nextToken.type !== "weight-marker") {
              html += " ";
            }
          }
        }
      });

      return html;
    }

    // =============================================================================
    // å›¾ç‰‡å…ƒæ•°æ®è§£ææ¨¡å—
    // =============================================================================
    
    // PNG Chunk è§£æ
    function extractPngChunks(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      const chunks = [];
      let offset = 8; // Skip PNG signature

      while (offset < arrayBuffer.byteLength - 12) {
        const length = dataView.getUint32(offset, false);
        const type = String.fromCharCode(
          dataView.getUint8(offset + 4),
          dataView.getUint8(offset + 5),
          dataView.getUint8(offset + 6),
          dataView.getUint8(offset + 7)
        );

        const data = new Uint8Array(arrayBuffer, offset + 8, length);
        chunks.push({ type, data });

        offset += length + 12; // length + type + data + crc
      }

      return chunks;
    }

    function decodePngTextChunk(data, chunkType) {
      if (chunkType === "tEXt") {
        const nullIndex = data.indexOf(0);
        const keyword = new TextDecoder().decode(data.slice(0, nullIndex));
        const text = new TextDecoder().decode(data.slice(nullIndex + 1));
        return { keyword, text };
      } else if (chunkType === "iTXt") {
        // iTXtæ ¼å¼æ›´å¤æ‚ï¼ŒåŒ…å«å‹ç¼©æ ‡å¿—å’Œè¯­è¨€æ ‡ç­¾
        const filteredData = data.filter((x) => x != 0x0);
        const header = new TextDecoder().decode(filteredData.slice(0, 11));
        if (header === "Description") {
          const txt = new TextDecoder().decode(filteredData.slice(11));
          return { keyword: "Description", text: txt };
        } else {
          const txt = new TextDecoder().decode(filteredData);
          return { keyword: "Comment", text: txt };
        }
      }
      return { keyword: "Unknown", text: "" };
    }

    // æå–å…ƒæ•°æ®
    async function extractMetadata(file) {
      if (file.type === "image/png") {
        const buf = await file.arrayBuffer();
        let chunks = [];
        try {
          chunks = extractPngChunks(buf);
        } catch (err) {
          console.error("PNG chunk è§£æå¤±è´¥:", err);
          return [];
        }

        const textChunks = chunks
          .filter(function (chunk) {
            return chunk.type === "tEXt" || chunk.type === "iTXt";
          })
          .map(function (chunk) {
            return decodePngTextChunk(chunk.data, chunk.type);
          })
          .filter(chunk => chunk.keyword !== "Unknown");

        console.log("æå–çš„æ–‡æœ¬å—:", textChunks);
        return textChunks;
      }
      return [];
    }

    // =============================================================================
    // éšå†™æœ¯è§£ææ¨¡å—
    // =============================================================================
    
    // éšå†™æœ¯EXIFæå–
    async function getStealthExif(src) {
      let time = performance.now();

      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: true });
      let img = new Image();
      img.src = src;

      await img.decode();

      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      let imageData = ctx.getImageData(0, 0, img.width, img.height);
      let lowestData = [];

      for (let x = 0; x < img.width; x++) {
        for (let y = 0; y < img.height; y++) {
          let index = (y * img.width + x) * 4;
          let a = imageData.data[index + 3];
          lowestData.push(a & 1);
        }
      }

      console.log("éšå†™æœ¯æå–è€—æ—¶: ", performance.now() - time, "ms");

      // æ•°æ®è¯»å–å™¨ç±»
      class DataReader {
        constructor(data) {
          this.data = data;
          this.index = 0;
        }

        readBit() {
          return this.data[this.index++];
        }

        readNBits(n) {
          let bits = [];
          for (let i = 0; i < n; i++) {
            bits.push(this.readBit());
          }
          return bits;
        }

        readByte() {
          let byte = 0;
          for (let i = 0; i < 8; i++) {
            byte |= this.readBit() << (7 - i);
          }
          return byte;
        }

        readNBytes(n) {
          let bytes = [];
          for (let i = 0; i < n; i++) {
            bytes.push(this.readByte());
          }
          return bytes;
        }

        readInt32() {
          let bytes = this.readNBytes(4);
          return new DataView(new Uint8Array(bytes).buffer).getInt32(0, false);
        }
      }

      const magic = CONFIG.NOVELAI.STEGANOGRAPHY_MAGIC;
      const reader = new DataReader(lowestData);
      const readMagic = reader.readNBytes(magic.length);
      const magicString = String.fromCharCode.apply(null, readMagic);

      if (magic === magicString) {
        console.log("æ‰¾åˆ°éšå†™æ•°æ®ï¼");
        const dataLength = reader.readInt32();
        console.log("æ•°æ®é•¿åº¦:", dataLength);
        const gzipData = reader.readNBytes(dataLength / 8);

        const data = pako.ungzip(new Uint8Array(gzipData));
        const jsonString = new TextDecoder().decode(new Uint8Array(data));
        const json = JSON.parse(jsonString);
        return json;
      } else {
        console.log("æœªæ‰¾åˆ°éšå†™æ•°æ®æ ‡è®°");
      }

      return null;
    }

    // =============================================================================
    // æ•°æ®è§£ææ¨¡å—
    // =============================================================================
    
    // è§£æNovelAIçš„JSONæ•°æ®
    function parseNovelAIData(details) {
      const result = {
        basic: [],
        prompts: [],
        technical: [],
      };

      // ä¸»Prompt
      if (details.prompt) {
        result.prompts.push({
          label: "ä¸»Prompt",
          value: details.prompt,
          copyable: true,
        });
      }

      // è´Ÿé¢Prompt
      if (details.uc) {
        result.prompts.push({
          label: "è´Ÿé¢Prompt",
          value: details.uc,
          copyable: true,
        });
      }

      // V4 è§’è‰²Prompts - æŒ‰ç…§è§’è‰²é¡ºåºæ˜¾ç¤º
      const charPrompts = [];
      const charNegativePrompts = [];

      if (details.v4_prompt && details.v4_prompt.caption && details.v4_prompt.caption.char_captions) {
        details.v4_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charPrompts[index] = {
              label: `è§’è‰²${index + 1} Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      if (details.v4_negative_prompt && details.v4_negative_prompt.caption && details.v4_negative_prompt.caption.char_captions) {
        details.v4_negative_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charNegativePrompts[index] = {
              label: `è§’è‰²${index + 1} è´Ÿé¢Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      // æŒ‰ç…§è§’è‰²é¡ºåºæ·»åŠ Promptå’Œè´Ÿé¢Prompt
      const maxCharIndex = Math.max(charPrompts.length, charNegativePrompts.length);
      for (let i = 0; i < maxCharIndex; i++) {
        if (charPrompts[i]) {
          result.prompts.push(charPrompts[i]);
        }
        if (charNegativePrompts[i]) {
          result.prompts.push(charNegativePrompts[i]);
        }
      }

      // æŠ€æœ¯å‚æ•°
      result.technical.push({
        label: "é‡‡æ ·å™¨",
        value: details.sampler || "Unknown",
      });
      result.technical.push({
        label: "æ­¥æ•°",
        value: details.steps || "Unknown",
      });
      result.technical.push({
        label: "å°ºå¯¸",
        value: `${details.width || "?"} Ã— ${details.height || "?"}`,
      });
      result.technical.push({
        label: "CFG Scale",
        value: details.scale || "Unknown",
      });
      result.technical.push({
        label: "ç§å­",
        value: details.seed || "Unknown",
      });
      if (details.noise_schedule) {
        result.technical.push({
          label: "å™ªå£°è®¡åˆ’",
          value: details.noise_schedule,
        });
      }
      if (details.cfg_rescale !== undefined) {
        result.technical.push({
          label: "CFG Rescale",
          value: details.cfg_rescale,
        });
      }
      if (details.strength !== undefined) {
        result.technical.push({
          label: "Strength",
          value: details.strength,
        });
      }
      if (details.noise !== undefined) {
        result.technical.push({
          label: "Noise",
          value: details.noise,
        });
      }
      if (details.generation_time !== undefined) {
        result.technical.push({
          label: "ç”Ÿæˆæ—¶é—´",
          value: `${details.generation_time.toFixed(4)}s`,
        });
      }
      if (details.request_type) {
        result.technical.push({
          label: "è¯·æ±‚ç±»å‹",
          value: details.request_type,
          wide: true,
        });
      }

      return result;
    }

    // å¤„ç†WebUIæ ¼å¼
    function parseWebUIData(text) {
      const result = {
        prompts: [],
        technical: [],
      };

      const parts = text.split("Steps: ");
      if (parts.length >= 2) {
        const promptPart = parts[0];
        const paramsPart = "Steps: " + parts[1];

        const promptSplit = promptPart.split("Negative prompt: ");

        result.prompts.push({
          label: "æ­£é¢æç¤ºè¯",
          value: promptSplit[0].trim(),
          copyable: true,
        });

        if (promptSplit.length > 1) {
          result.prompts.push({
            label: "è´Ÿé¢æç¤ºè¯",
            value: promptSplit[1].trim(),
            copyable: true,
          });
        }

        // è§£æå‚æ•°
        const params = paramsPart.match(/(\w+[\s\w]*): ([^,]+)/g);
        if (params) {
          params.forEach((param) => {
            const [key, value] = param.split(": ");
            result.technical.push({
              label: key,
              value: value,
            });
          });
        }
      }

      return result;
    }

    // å¤„ç†WebUIæ ¼å¼æ•°æ®
    function handleWebUiTag(data) {
      let [prompts, otherParas] = data.text.split("Steps: ");
      let promptSplit = prompts.split("Negative prompt: ");
      let negativePrompt = promptSplit.length > 1 ? promptSplit[1] : "æ— ";
      return [
        {
          label: "æç¤ºè¯",
          value: promptSplit[0],
          copyable: true,
        },
        {
          label: "è´Ÿé¢æç¤ºè¯",
          value: negativePrompt,
          copyable: true,
        },
        {
          label: "å…¶ä»–å‚æ•°",
          value: "Steps: " + otherParas,
          copyable: true,
        },
      ];
    }

    // =============================================================================
    // UIæ¸²æŸ“æ¨¡å—
    // =============================================================================
    
    // æ¸²æŸ“æŠ€æœ¯å‚æ•°åˆ°å·¦ä¾§
    function renderTechnicalParams(technicalData) {
      const technicalPanel = document.getElementById("technicalPanel");
      const technicalParams = document.getElementById("technicalParams");

      if (technicalData && technicalData.length > 0) {
        technicalParams.innerHTML = "";

        technicalData.forEach((item) => {
          const paramEl = document.createElement("div");
          paramEl.className = "tech-param-item";
          if (item.wide) {
            paramEl.classList.add("wide");
          }

          const labelEl = document.createElement("div");
          labelEl.className = "tech-param-label";
          labelEl.textContent = item.label;

          const valueEl = document.createElement("div");
          valueEl.className = "tech-param-value";
          valueEl.textContent = item.value.toString();

          // æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
          paramEl.addEventListener("click", () => {
            copyToClipboard(item.value.toString());
          });

          paramEl.appendChild(labelEl);
          paramEl.appendChild(valueEl);
          technicalParams.appendChild(paramEl);
        });

        technicalPanel.style.display = "block";
      } else {
        technicalPanel.style.display = "none";
      }
    }

    // æ¸²æŸ“ä¿¡æ¯åˆ°å³ä¾§ï¼ˆä¸åŒ…æ‹¬æŠ€æœ¯å‚æ•°ï¼‰
    function renderInfo(data) {
      const container = document.getElementById("infoContainer");
      container.innerHTML = "";

      // Prompts - è¿‡æ»¤æ‰ä¸éœ€è¦çš„å­—æ®µ
      if (data.prompts && data.prompts.length > 0) {
        const filteredPrompts = data.prompts.filter((item) => {
          if (!item || (!item.label && !item.key)) {
            return false; // è¿‡æ»¤æ‰æ— æ•ˆçš„é¡¹ç›®
          }
          const label = (item.label || item.key).toLowerCase();
          return !label.includes("title") && !label.includes("description") && !label.includes("åŸºç¡€caption") && !label.includes("è´Ÿé¢åŸºç¡€caption") && !label.includes("generation_time");
        });

        if (filteredPrompts.length > 0) {
          const section = createSection("Prompts", "âœ¨", filteredPrompts);
          container.appendChild(section);
        }
      }

      // EXIFä¿¡æ¯
      if (data.exif && data.exif.length > 0) {
        const section = createSection("EXIFä¿¡æ¯", "ğŸ“·", data.exif);
        container.appendChild(section);
      }
    }

    function createSection(title, icon, items) {
      const section = document.createElement("div");
      section.className = "info-section";

      const titleEl = document.createElement("h2");
      titleEl.className = "section-title";
      titleEl.innerHTML = `<span class="section-icon">${icon}</span>${title}`;
      section.appendChild(titleEl);

      items.forEach((item, index) => {
        // è·³è¿‡æ— æ•ˆçš„é¡¹ç›®
        if (!item || (!item.label && !item.key) || item.value === undefined || item.value === null) {
          console.warn("è·³è¿‡æ— æ•ˆé¡¹ç›®:", item);
          return;
        }

        const itemEl = document.createElement("div");
        itemEl.className = "info-item";
        itemEl.style.animationDelay = `${index * CONFIG.UI.ANIMATION_DELAY_STEP}s`;

        const labelEl = document.createElement("div");
        labelEl.className = "info-label";

        const labelText = document.createElement("span");
        const itemLabel = item.label || item.key || "æœªçŸ¥å­—æ®µ";
        labelText.textContent = itemLabel;
        labelEl.appendChild(labelText);

        // æ£€æŸ¥æ˜¯å¦ä¸ºpromptç›¸å…³å†…å®¹
        const labelToCheck = itemLabel.toLowerCase();
        const isPrompt = labelToCheck.includes("prompt") || labelToCheck.includes("caption") || labelToCheck === "description";

        if (item.copyable) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.textContent = "å¤åˆ¶";

          // å¯¹äºpromptç±»å‹ï¼Œå¤åˆ¶æ ¼å¼åŒ–åçš„æ–‡æœ¬ï¼›å¯¹äºå…¶ä»–ç±»å‹ï¼Œå¤åˆ¶åŸå§‹æ–‡æœ¬
          if (isPrompt && item.value && typeof item.value === "string") {
            const formattedText = formatPrompt(item.value);
            copyBtn.onclick = () => copyToClipboard(formattedText);
          } else {
            copyBtn.onclick = () => copyToClipboard(item.value);
          }

          labelEl.appendChild(copyBtn);
        }

        itemEl.appendChild(labelEl);

        const valueEl = document.createElement("div");
        valueEl.className = "info-value";

        if (isPrompt && item.value && typeof item.value === "string") {
          // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿé¢prompt
          const isNegativePrompt = labelToCheck.includes("è´Ÿé¢") || labelToCheck.includes("negative");

          // å¯¹promptå†…å®¹è¿›è¡Œæ ¼å¼åŒ–å’Œé«˜äº®
          valueEl.classList.add("formatted-prompt");
          valueEl.innerHTML = renderHighlightedPrompt(item.value, isNegativePrompt);
        } else {
          // æ™®é€šæ–‡æœ¬å†…å®¹
          valueEl.textContent = item.value;
        }

        itemEl.appendChild(valueEl);

        section.appendChild(itemEl);
      });

      return section;
    }

    // =============================================================================
    // å›¾ç‰‡é¢„è§ˆå’ŒçŠ¶æ€ç®¡ç†æ¨¡å—
    // =============================================================================
    
    // åº”ç”¨çŠ¶æ€ç®¡ç†
    const AppState = {
      currentFile: null,
      
      setCurrentFile(file) {
        this.currentFile = file;
      },
      
      getCurrentFile() {
        return this.currentFile;
      },
      
      clearCurrentFile() {
        this.currentFile = null;
      }
    };

    // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆå’ŒåŸºæœ¬ä¿¡æ¯
    function showImagePreview(file, modelInfo = null) {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const imageFilename = document.getElementById("imageFilename");
      const imageDetails = document.getElementById("imageDetails");

      // è¯»å–å›¾ç‰‡å¹¶æ˜¾ç¤ºé¢„è§ˆ
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewImage.style.display = "block";

        // éšè—ä¸Šä¼ æç¤ºï¼Œæ˜¾ç¤ºå›¾ç‰‡ä¿¡æ¯
        uploadContent.style.display = "none";
        uploadArea.classList.add("has-image");

        // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
        // è®¡ç®—å¯ç”¨å®½åº¦ï¼Œå¤§çº¦æ˜¯å®¹å™¨å®½åº¦å‡å»padding
        const displayFilename = truncateFilename(file.name, CONFIG.UI.FILENAME_MAX_WIDTH);
        imageFilename.textContent = displayFilename;
        imageFilename.title = file.name; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºå®Œæ•´æ–‡ä»¶å

        // æ·»åŠ ç‚¹å‡»å¤åˆ¶å®Œæ•´æ–‡ä»¶ååŠŸèƒ½
        imageFilename.onclick = () => {
          copyToClipboard(file.name);
        };

        // æ„å»ºè¯¦ç»†ä¿¡æ¯ï¼Œå¦‚æœæœ‰æ¨¡å‹ä¿¡æ¯å°±æ˜¾ç¤ºæ¨¡å‹ï¼Œå¦åˆ™æ˜¾ç¤ºæ–‡ä»¶ç±»å‹
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">${modelInfo ? "æ¨¡å‹:" : "ç±»å‹:"}</span>
                        <span class="detail-value">${modelInfo || file.type}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
        imageInfo.style.display = "block";
      };
      reader.readAsDataURL(file);
    }

    // æ›´æ–°å›¾ç‰‡ä¿¡æ¯ä¸­çš„æ¨¡å‹æ˜¾ç¤º
    function updateImageModelInfo(modelInfo) {
      const imageDetails = document.getElementById("imageDetails");
      const file = AppState.getCurrentFile();

      if (imageDetails && modelInfo && file) {
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">æ¨¡å‹:</span>
                        <span class="detail-value">${modelInfo}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
      }
    }

    // é‡ç½®ç•Œé¢çš„å‡½æ•°
    function resetInterface() {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const technicalPanel = document.getElementById("technicalPanel");
      const rightPanel = document.getElementById("rightPanel");
      
      uploadArea.classList.remove("has-image");
      uploadContent.style.display = "flex";
      previewImage.style.display = "none";
      imageInfo.style.display = "none";
      technicalPanel.style.display = "none";
      rightPanel.style.display = "none";
      AppState.clearCurrentFile();

      // æ¸…é™¤æ–‡ä»¶åçš„ç‚¹å‡»äº‹ä»¶
      const imageFilename = document.getElementById("imageFilename");
      if (imageFilename) {
        imageFilename.onclick = null;
        imageFilename.title = "";
      }
    }

    // =============================================================================
    // ä¸»è¦å¤„ç†æµç¨‹
    // =============================================================================
    
         // å¤„ç†éšå†™æœ¯æ•°æ®
     async function processStealthExif(imageSrc) {
       console.log("å°è¯•éšå†™æœ¯æå–...");
       const exif = await getStealthExif(imageSrc);
       
       if (!exif) {
         return {
           metaType: CONFIG.METADATA_TYPES.UNKNOWN,
           promptsData: [{
             label: "æç¤º",
             value: "ğŸ˜­ æ— æ³•è¯»å–åˆ°å›¾åƒ Metadataï¼Œè¿™å¯èƒ½ä¸æ˜¯ä¸€å¼  Stable Diffusion ç”Ÿæˆçš„å›¾ã€‚æˆ–è€…ä¸æ˜¯åŸå›¾, ç»è¿‡äº†å‹ç¼©ã€‚",
             copyable: false,
           }],
           stealthExifData: null
         };
       }

      console.log("éšå†™æœ¯æå–æˆåŠŸ:", exif);
      const promptsData = [];

      // å¤„ç†éšå†™æœ¯æ•°æ®
      for (const [key, value] of Object.entries(exif)) {
        if (key === "Comment") {
          // CommentåŒ…å«å®Œæ•´çš„JSONæ•°æ®ï¼Œéœ€è¦è§£æ
          try {
            const jsonData = JSON.parse(value);
            console.log("éšå†™æœ¯Comment JSON data:", jsonData);
            const novelAIData = parseNovelAIData(jsonData);
            promptsData.push(...novelAIData.prompts);
            // è®¾ç½®æŠ€æœ¯å‚æ•°
            renderTechnicalParams(novelAIData.technical);
          } catch (e) {
            console.error("è§£æéšå†™æœ¯Comment JSONå¤±è´¥:", e);
            promptsData.push({
              label: "Comment",
              value: value,
              copyable: true,
            });
          }
        } else if (key === "Description") {
          // Descriptioné€šå¸¸æ˜¯ä¸»prompt
          promptsData.push({
            label: "ä¸»Prompt (Description)",
            value: value,
            copyable: true,
          });
        }
      }

      // æ›´æ–°å›¾ç‰‡æ˜¾ç¤ºä¸­çš„æ¨¡å‹ä¿¡æ¯
      if (exif.Source) {
        updateImageModelInfo(exif.Source);
      }

             return {
         metaType: CONFIG.METADATA_TYPES.NOVELAI,
         promptsData,
         stealthExifData: exif
       };
    }

         // å¤„ç†PNGæ–‡æœ¬å—æ•°æ®
     function processPngTextChunks(metadata) {
       const promptsData = [];
       let metaType = CONFIG.METADATA_TYPES.SD_WEBUI;

      if (metadata.length === 1 && metadata[0].keyword === "parameters") {
        // SD WebUI æ ¼å¼
        const webUIData = handleWebUiTag(metadata[0]);
        promptsData.push(...webUIData);
        renderTechnicalParams([]);
      } else {
        // å¤„ç†PNGæ–‡æœ¬å—ä¸­çš„NovelAI Commentæ ¼å¼
        for (const meta of metadata) {
          if (meta.keyword === "Comment") {
            try {
              const jsonData = JSON.parse(meta.text);
              console.log("PNGæ–‡æœ¬å— NovelAI JSON data:", jsonData);
              const novelAIData = parseNovelAIData(jsonData);
              promptsData.push(...novelAIData.prompts);
              // è®¾ç½®æŠ€æœ¯å‚æ•°
              renderTechnicalParams(novelAIData.technical);
              metaType = CONFIG.METADATA_TYPES.NOVELAI;
            } catch (e) {
              console.error("è§£æPNGæ–‡æœ¬å—Comment JSONå¤±è´¥:", e);
              promptsData.push({
                label: meta.keyword,
                value: meta.text,
                copyable: true,
              });
            }
          } else if (meta.keyword === "Source") {
            // æ›´æ–°æ¨¡å‹ä¿¡æ¯æ˜¾ç¤º
            if (meta.text) {
              updateImageModelInfo(meta.text);
            }
          } else if (meta.keyword === "Description") {
            promptsData.push({
              label: "ä¸»Prompt (Description)",
              value: meta.text,
              copyable: true,
            });
          } else if (meta.keyword !== "Software" && meta.keyword !== "Generation time") {
            // å…¶ä»–éåŸºç¡€ä¿¡æ¯çš„å­—æ®µä½œä¸ºpromptå¤„ç†
            promptsData.push({
              label: meta.keyword,
              value: meta.text,
              copyable: true,
            });
          }
        }
      }

      return { metaType, promptsData };
    }

    // æ„å»ºåŸºç¡€ä¿¡æ¯
    function buildBasicInfo(file, metaType, stealthExifData) {
      const basicInfo = [
        { label: "æ–‡ä»¶å", value: file.name },
        { label: "æ–‡ä»¶å¤§å°", value: formatFileSize(file.size) },
      ];

             // å¦‚æœæœ‰æ¨¡å‹ä¿¡æ¯ï¼Œæ·»åŠ åˆ°åŸºç¡€ä¿¡æ¯ä¸­
       if (metaType === CONFIG.METADATA_TYPES.NOVELAI && stealthExifData) {
        if (stealthExifData.Software) {
          basicInfo.push({ label: "è½¯ä»¶", value: stealthExifData.Software });
        }
        if (stealthExifData.Source) {
          basicInfo.push({ label: "æ¨¡å‹", value: stealthExifData.Source });
        }
        if (stealthExifData["Generation time"]) {
          basicInfo.push({ label: "ç”Ÿæˆæ—¶é—´", value: stealthExifData["Generation time"] + "s" });
        }
      }

      return basicInfo;
    }

    // å¤„ç†å›¾ç‰‡ä¸»å‡½æ•°
    async function processImage(file) {
      const rightPanel = document.getElementById("rightPanel");

      // ä¿å­˜å½“å‰æ–‡ä»¶å¼•ç”¨ç”¨äºåç»­æ›´æ–°
      AppState.setCurrentFile(file);

      // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
      showImagePreview(file);

      // è¯»å–å›¾ç‰‡ä½œä¸ºDataURLç”¨äºéšå†™æœ¯æå–
      const reader = new FileReader();
      reader.onload = async (e) => {
        const imageSrc = e.target.result;

        try {
          // æå–å…ƒæ•°æ®
          const metadata = await extractMetadata(file);
          console.log("æå–çš„å…ƒæ•°æ®:", metadata);

          let metaType, promptsData, stealthExifData = null;

          if (metadata.length === 0) {
            // å°è¯•éšå†™æœ¯æå–
            const stealthResult = await processStealthExif(imageSrc);
            metaType = stealthResult.metaType;
            promptsData = stealthResult.promptsData;
            stealthExifData = stealthResult.stealthExifData;
          } else {
            // å¤„ç†PNGæ–‡æœ¬å—
            const pngResult = processPngTextChunks(metadata);
            metaType = pngResult.metaType;
            promptsData = pngResult.promptsData;
          }

          // æ„å»ºå®Œæ•´æ•°æ®ç»“æ„
          const basicInfo = buildBasicInfo(file, metaType, stealthExifData);
          const allData = {
            basic: basicInfo,
            prompts: promptsData,
            technical: [],
            exif: [],
          };

                     // æ·»åŠ SD-WEBUIå®Œæ•´ä¿¡æ¯
           if (metaType === CONFIG.METADATA_TYPES.SD_WEBUI && metadata.length > 0) {
            allData.prompts.push({
              key: "å®Œæ•´ç”Ÿæˆä¿¡æ¯",
              value: metadata[0]["text"],
              copyable: true,
            });
          }

                     // å¦‚æœä¸æ˜¯NovelAIæ ¼å¼ï¼Œæ¸²æŸ“ç©ºçš„æŠ€æœ¯å‚æ•°
           if (metaType !== CONFIG.METADATA_TYPES.NOVELAI) {
            renderTechnicalParams([]);
          }

          // æ¸²æŸ“ä¿¡æ¯åˆ°å³ä¾§
          renderInfo(allData);
          rightPanel.style.display = "block";

                 } catch (error) {
           ErrorHandler.handleProcessingError(error, "å¤„ç†å›¾ç‰‡");
         }
      };

      reader.readAsDataURL(file);
    }

    // =============================================================================
    // åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š
    // =============================================================================
    
    // åˆå§‹åŒ–ä¸Šä¼ åŠŸèƒ½
    document.addEventListener("DOMContentLoaded", () => {
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");

      uploadArea.addEventListener("click", (e) => {
        // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œè¯¢é—®æ˜¯å¦è¦é€‰æ‹©æ–°å›¾ç‰‡
        if (e.target.tagName === "IMG" && e.target.id === "previewImage") {
          if (confirm("è¦é€‰æ‹©æ–°çš„å›¾ç‰‡å—ï¼Ÿ")) {
            resetInterface();
            fileInput.click();
          }
        } else if (!uploadArea.classList.contains("has-image")) {
          // å¦‚æœè¿˜æ²¡æœ‰å›¾ç‰‡ï¼Œç›´æ¥æ‰“å¼€é€‰æ‹©
          fileInput.click();
        }
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
        // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
        fileInput.value = "";
      });

      // æ‹–æ‹½åŠŸèƒ½
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("drag-over");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("drag-over");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("drag-over");

        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
      });
    });
  </script>
</body>

</html>