<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NovelAI å›¾ç‰‡è§£æ</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        background-color: #f5f7fa;
        color: #333;
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        font-weight: 700;
      }

      .header p {
        font-size: 1.1rem;
        opacity: 0.9;
      }

      .main-content {
        display: grid;
        grid-template-columns: 2fr 3fr;
        gap: 30px;
        align-items: start;
      }

      @media (max-width: 968px) {
        .main-content {
          grid-template-columns: 1fr;
          gap: 15px;
        }

        .left-column {
          margin-bottom: 0;
        }

        .technical-panel {
          margin-bottom: 0;
        }

        .right-panel {
          margin-top: 0;
        }
      }

      .left-column {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      .left-panel {
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .technical-panel {
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      }

      .upload-area {
        border: 3px dashed #e0e6ed;
        border-radius: 12px;
        padding: 60px 20px;
        text-align: center;
        cursor: pointer;
        transition: all 0.3s ease;
        background: #f8f9fc;
        width: 100%;
        min-height: 350px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        position: relative;
        overflow: hidden;
      }

      .upload-area:hover {
        border-color: #667eea;
        background: #f0f2ff;
      }

      .upload-area.drag-over {
        border-color: #667eea;
        background: #e8ebff;
        transform: scale(1.02);
      }

      .upload-area.has-image {
        padding: 20px;
        background: #fff;
        cursor: default;
        min-height: auto;
        border-color: #d0d7de;
      }

      .upload-area.has-image:hover {
        background: #f8f9fc;
        border-color: #667eea;
      }

      .upload-area.has-image .preview-image {
        cursor: pointer;
      }

      .image-info-compact {
        text-align: center;
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid #e8ebf4;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        width: 100%;
      }

      .image-info-compact .image-filename {
        font-size: 0.95rem;
        color: #333;
        font-weight: 500;
        margin-bottom: 5px;
        white-space: nowrap;
        overflow: hidden;
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .image-info-compact .image-filename:hover {
        color: #667eea;
      }

      .image-info-compact .image-details {
        font-size: 0.85rem;
        color: #666;
        cursor: help;
      }

      .section-icon {
        color: #667eea;
      }

      #uploadContent {
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .upload-icon {
        font-size: 48px;
        color: #667eea;
        margin-bottom: 20px;
      }

      .upload-text {
        color: #666;
        font-size: 1.1rem;
        margin-bottom: 10px;
      }

      .upload-hint {
        color: #999;
        font-size: 0.9rem;
      }

      .preview-image {
        max-width: 100%;
        max-height: 350px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        display: block;
        margin: 0 auto;
        cursor: pointer;
      }

      .preview-image:hover {
        box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
      }

      .image-filename {
        font-size: 1.1rem;
        font-weight: 500;
        color: #333;
        margin-bottom: 10px;
        word-break: break-all;
      }

      .image-details {
        display: flex;
        justify-content: center;
        gap: 20px;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .detail-item {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.9rem;
        color: #666;
      }

      .detail-label {
        color: #999;
      }

      .detail-value {
        color: #333;
        font-weight: 500;
      }

      .right-panel {
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        max-height: 90vh;
        overflow-y: auto;
      }

      .info-section {
        margin-bottom: 30px;
      }

      .section-title {
        font-size: 1.5rem;
        font-weight: 600;
        margin-bottom: 20px;
        color: #444;
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .info-item {
        background: #f8f9fc;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 15px;
        border: 1px solid #e8ebf4;
        transition: all 0.3s ease;
      }

      .info-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }

      .info-label {
        font-weight: 600;
        color: #555;
        margin-bottom: 8px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .info-value {
        color: #666;
        line-height: 1.6;
        word-break: break-word;
        white-space: pre-wrap;
        font-family: "Monaco", "Consolas", monospace;
        font-size: 0.9rem;
      }

      .info-value.formatted-prompt {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        font-size: 0.95rem;
        line-height: 1.7;
        word-break: break-word;
        overflow-wrap: break-word;
      }

      /* Promptæƒé‡é«˜äº®æ ·å¼ */
      .prompt-tag {
        display: inline;
        white-space: nowrap;
      }

      .prompt-tag.weight-high {
        color: #e53e3e;
      }

      .prompt-tag.weight-low {
        color: #3182ce;
      }

      .prompt-tag.weight-normal {
        color: #333;
      }

      .prompt-tag.default-tag {
        color: #a0aec0;
        opacity: 0.7;
      }

      .prompt-weight-marker {
        color: #805ad5;
        font-weight: 600;
        opacity: 0.8;
        white-space: nowrap;
      }

      .prompt-comma {
        color: #a0aec0;
      }

      .tech-params {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 15px;
        background: #f8f9fc;
        border-radius: 12px;
        padding: 20px;
        border: 1px solid #e8ebf4;
      }

      @media (max-width: 768px) {
        .tech-params {
          grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
          gap: 12px;
          padding: 15px;
        }
      }

      .tech-param-item {
        display: flex;
        flex-direction: column;
        gap: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        padding: 8px;
        border-radius: 6px;
      }

      .tech-param-item:hover {
        background-color: rgba(102, 126, 234, 0.1);
      }

      .tech-param-item.wide {
        grid-column: span 2;
      }

      .tech-param-label {
        font-size: 0.85rem;
        color: #888;
        font-weight: 500;
      }

      .tech-param-value {
        font-size: 0.95rem;
        color: #333;
        font-weight: 600;
        font-family: "Monaco", "Consolas", monospace;
      }

      .copy-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.85rem;
        transition: all 0.3s ease;
      }

      .copy-btn:hover {
        background: #5a67d8;
        transform: translateY(-1px);
      }

      .copy-btn:active {
        transform: translateY(0);
      }

      .json-viewer {
        background: #f5f7fa;
        border-radius: 8px;
        padding: 15px;
        overflow-x: auto;
        font-family: "Monaco", "Consolas", monospace;
        font-size: 0.85rem;
      }

      .loading {
        text-align: center;
        padding: 40px;
        color: #999;
      }

      .error {
        background: #fee;
        color: #c33;
        padding: 15px;
        border-radius: 8px;
        margin-top: 20px;
      }

      .footer {
        text-align: center;
        margin-top: 50px;
        padding: 20px;
        color: #999;
        font-size: 0.9rem;
        clear: both;
      }

      .footer a {
        color: #667eea;
        text-decoration: none;
      }

      .footer a:hover {
        text-decoration: underline;
      }

      /* æ»šåŠ¨æ¡æ ·å¼ */
      .right-panel::-webkit-scrollbar {
        width: 8px;
      }

      .right-panel::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 4px;
      }

      .right-panel::-webkit-scrollbar-thumb {
        background: #ccc;
        border-radius: 4px;
      }

      .right-panel::-webkit-scrollbar-thumb:hover {
        background: #999;
      }

      /* åŠ¨ç”» */
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .info-item {
        animation: fadeIn 0.5s ease;
      }

      .toast {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #667eea;
        color: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
        opacity: 0;
        transform: translateY(-20px);
        transition: all 0.3s ease;
        z-index: 1000;
      }

      .toast.show {
        opacity: 1;
        transform: translateY(0);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>ğŸ¨ NovelAI å›¾ç‰‡è§£æ</h1>
        <p>ä» NovelAI ç”Ÿæˆçš„å›¾ç‰‡ä¸­æå–è¯¦ç»†å‚æ•°ä¿¡æ¯</p>
      </div>

      <div class="main-content">
        <div class="left-column">
          <div class="left-panel">
            <div class="upload-area" id="uploadArea">
              <div id="uploadContent">
                <div class="upload-icon">ğŸ“</div>
                <div class="upload-text">æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ</div>
                <div class="upload-hint">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
              </div>
              <!-- é¢„è§ˆå›¾ç‰‡ -->
              <img id="previewImage" class="preview-image" style="display: none" alt="é¢„è§ˆå›¾ç‰‡" />
              <!-- åŸºç¡€ä¿¡æ¯ -->
              <div class="image-info-compact" id="imageInfo" style="display: none">
                <div class="image-filename" id="imageFilename"></div>
                <div class="image-details" id="imageDetails"></div>
              </div>
              <input type="file" id="fileInput" accept="image/*" style="display: none" />
            </div>
          </div>

          <!-- æŠ€æœ¯å‚æ•°åŒºåŸŸ -->
          <div class="technical-panel" id="technicalPanel" style="display: none">
            <div id="technicalParams" class="tech-params"></div>
          </div>
        </div>

        <div class="right-panel" id="rightPanel" style="display: none">
          <div id="infoContainer"></div>
        </div>
      </div>

      <div class="footer">
        <p>* æ‰€æœ‰è¿ç®—å®Œå…¨åœ¨æ‚¨çš„è®¾å¤‡ä¸Šè¿è¡Œï¼Œä¸ä¼šä¸Šä¼ åˆ°äº‘ç«¯</p>
        <p>Made by <a href="https://github.com/Natsukage">@Natsukage</a></p>
      </div>
    </div>

    <div class="toast" id="toast"></div>

    <!-- å¼•å…¥å¿…è¦çš„åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <script>
      // å·¥å…·å‡½æ•°
      function showToast(message) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }

      function copyToClipboard(text) {
        navigator.clipboard
          .writeText(text)
          .then(() => {
            showToast("å¤åˆ¶æˆåŠŸï¼");
          })
          .catch(() => {
            showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
          });
      }

      function formatFileSize(bytes) {
        if (bytes < 1024) return bytes + " B";
        else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + " KB";
        else return (bytes / 1048576).toFixed(2) + " MB";
      }

      // å¤„ç†æ–‡ä»¶åæ˜¾ç¤º - ä¸­é—´çœç•¥ï¼Œä¿ç•™æ‰©å±•å
      function truncateFilename(filename, maxWidth) {
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        context.font = '0.95rem -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

        // å¦‚æœæ–‡ä»¶åå®½åº¦å°äºæœ€å¤§å®½åº¦ï¼Œç›´æ¥è¿”å›
        if (context.measureText(filename).width <= maxWidth) {
          return filename;
        }

        // æå–æ–‡ä»¶åå’Œæ‰©å±•å
        const lastDotIndex = filename.lastIndexOf(".");
        const extension = lastDotIndex !== -1 ? filename.substring(lastDotIndex) : "";
        const nameWithoutExt = lastDotIndex !== -1 ? filename.substring(0, lastDotIndex) : filename;

        // è®¡ç®—çœç•¥å·å’Œæ‰©å±•åçš„å®½åº¦
        const ellipsisWidth = context.measureText("...").width;
        const extensionWidth = context.measureText(extension).width;

        // é¢„ç•™è‡³å°‘3ä¸ªå­—ç¬¦çš„ç©ºé—´åœ¨çœç•¥å·å‰ï¼Œé˜²æ­¢çœç•¥å·ç´§è´´æ‰©å±•å
        const minEndChars = Math.min(3, Math.floor(nameWithoutExt.length / 2));
        const endPart = nameWithoutExt.substring(nameWithoutExt.length - minEndChars);
        const endPartWidth = context.measureText(endPart).width;

        const totalEndWidth = ellipsisWidth + endPartWidth + extensionWidth;
        const availableWidth = maxWidth - totalEndWidth;

        // äºŒåˆ†æŸ¥æ‰¾åˆé€‚çš„æˆªæ–­é•¿åº¦
        let start = 0;
        let end = nameWithoutExt.length - minEndChars;
        let bestLength = 0;

        while (start <= end) {
          const mid = Math.floor((start + end) / 2);
          const truncated = nameWithoutExt.substring(0, mid);
          const width = context.measureText(truncated).width;

          if (width <= availableWidth) {
            bestLength = mid;
            start = mid + 1;
          } else {
            end = mid - 1;
          }
        }

        if (bestLength === 0) {
          return "..." + endPart + extension;
        }

        return nameWithoutExt.substring(0, bestLength) + "..." + endPart + extension;
      }

      // Promptæ ¼å¼åŒ–å‡½æ•°
      function formatPrompt(prompt) {
        if (!prompt || typeof prompt !== "string") return prompt;

        // 1. å»é™¤è½¬ä¹‰å­—ç¬¦
        let formatted = prompt.replace(/\\([()])/g, "$1");

        // 2. å»é™¤å¤šä½™çš„è¿ç»­é€—å·
        formatted = formatted.replace(/,{2,}/g, ",");

        // 3. æ ‡å‡†åŒ–é€—å·åçš„ç©ºæ ¼ï¼šç¡®ä¿é€—å·åæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç©ºæ ¼
        formatted = formatted.replace(/,\s*/g, ", ");

        // 4. å»é™¤å¼€å¤´å’Œç»“å°¾çš„é€—å·å’Œç©ºæ ¼
        formatted = formatted.replace(/^[\s,]+|[\s,]+$/g, "");

        return formatted;
      }

      // NovelAIé»˜è®¤æç¤ºè¯
      const NOVELAI_DEFAULT_POSITIVE_TAGS = ["very aesthetic", "location", "masterpiece", "no text", "feet", "rating:general"];

      const NOVELAI_DEFAULT_NEGATIVE_TAGS = [
        "blurry",
        "lowres",
        "upscaled",
        "artistic error",
        "film grain",
        "scan artifacts",
        "worst quality",
        "bad quality",
        "jpeg artifacts",
        "very displeasing",
        "chromatic aberration",
        "halftone",
        "multiple views",
        "logo",
        "too many watermarks",
        "negative space",
        "blank page",
      ];

      // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
      function isDefaultTag(tagContent, isNegativePrompt = false) {
        const content = tagContent.toLowerCase().trim();
        const defaultTags = isNegativePrompt ? NOVELAI_DEFAULT_NEGATIVE_TAGS : NOVELAI_DEFAULT_POSITIVE_TAGS;
        return defaultTags.some((defaultTag) => content === defaultTag.toLowerCase() || content.includes(defaultTag.toLowerCase()));
      }

      // NovelAIæƒé‡è§£æå™¨
      function parsePromptWeights(prompt) {
        const tokens = [];
        let i = 0;
        let currentWeight = 1.0;
        const weightStack = [1.0]; // ç”¨äºå¤„ç†åµŒå¥—æƒé‡

        while (i < prompt.length) {
          const char = prompt[i];

          // å¤„ç†æ•°å­—æƒé‡è¯­æ³•ï¼šæ•°å­—::
          if (char.match(/[-\d]/) && prompt.substring(i).match(/^[-\d.]+::/)) {
            const match = prompt.substring(i).match(/^([-\d.]+)::/);
            if (match) {
              const weight = parseFloat(match[1]);
              tokens.push({
                type: "weight-marker",
                content: match[0],
                weight: weight,
              });
              currentWeight = weight;
              weightStack.push(weight); // æ¨å…¥æ–°æƒé‡
              i += match[0].length;
              continue;
            }
          }

          // å¤„ç†æƒé‡ç»“æŸæ ‡è®°ï¼š::
          if (prompt.substring(i, i + 2) === "::") {
            tokens.push({
              type: "weight-marker",
              content: "::",
              weight: 1.0,
            });
            // æ¢å¤åˆ°æƒé‡æ ˆçš„ä¸Šä¸€å±‚
            if (weightStack.length > 1) {
              weightStack.pop();
              currentWeight = weightStack[weightStack.length - 1];
            } else {
              currentWeight = 1.0;
            }
            i += 2;
            continue;
          }

          // å¤„ç†æ—§å¼æƒé‡ï¼š{ å’Œ [
          if (char === "{") {
            const newWeight = currentWeight * 1.1;
            tokens.push({
              type: "weight-marker",
              content: "{",
              weight: newWeight,
            });
            currentWeight = newWeight;
            weightStack.push(newWeight);
            i++;
            continue;
          }

          if (char === "[") {
            const newWeight = currentWeight / 1.1;
            tokens.push({
              type: "weight-marker",
              content: "[",
              weight: newWeight,
            });
            currentWeight = newWeight;
            weightStack.push(newWeight);
            i++;
            continue;
          }

          if (char === "}" || char === "]") {
            tokens.push({
              type: "weight-marker",
              content: char,
              weight: 1.0,
            });
            if (weightStack.length > 1) {
              weightStack.pop();
              currentWeight = weightStack[weightStack.length - 1];
            } else {
              currentWeight = 1.0;
            }
            i++;
            continue;
          }

          // å¤„ç†é€—å·
          if (char === ",") {
            tokens.push({
              type: "comma",
              content: char,
              weight: 1.0,
            });
            i++;
            // è·³è¿‡é€—å·åçš„ç©ºæ ¼
            while (i < prompt.length && prompt[i] === " ") {
              i++;
            }
            continue;
          }

          // è·³è¿‡å…¶ä»–ç©ºæ ¼
          if (char === " ") {
            i++;
            continue;
          }

          // å¤„ç†æ™®é€šæ–‡æœ¬
          let textContent = "";
          while (i < prompt.length) {
            const currentChar = prompt[i];
            const nextTwoChars = prompt.substring(i, i + 2);

            // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡æ ‡è®°çš„å¼€å§‹
            if (prompt.substring(i).match(/^[-\d.]+::/)) {
              break;
            }

            // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡ç»“æŸæ ‡è®°
            if (nextTwoChars === "::") {
              break;
            }

            // æ£€æŸ¥æ˜¯å¦é‡åˆ°æ‹¬å·æˆ–é€—å·
            if ("{[}],".includes(currentChar)) {
              break;
            }

            textContent += currentChar;
            i++;
          }

          if (textContent.trim()) {
            tokens.push({
              type: "text",
              content: textContent.trim(),
              weight: currentWeight,
            });
          }
        }

        return tokens;
      }

      // æ¸²æŸ“æƒé‡é«˜äº®çš„Prompt
      function renderHighlightedPrompt(prompt, isNegativePrompt = false) {
        const formatted = formatPrompt(prompt);
        const tokens = parsePromptWeights(formatted);

        let html = "";

        tokens.forEach((token, index) => {
          if (token.type === "weight-marker") {
            html += `<span class="prompt-weight-marker">${escapeHtml(token.content)}</span>`;
          } else if (token.type === "comma") {
            // åœ¨é€—å·åæ·»åŠ çœŸå®ç©ºæ ¼ï¼Œç»™æµè§ˆå™¨æ­£ç¡®çš„æ¢è¡Œä½ç½®
            html += `<span class="prompt-comma">${escapeHtml(token.content)}</span> `;
          } else if (token.type === "text" && token.content) {
            let className = "prompt-tag weight-normal";

            // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
            const isDefault = isDefaultTag(token.content, isNegativePrompt);

            if (isDefault) {
              className = "prompt-tag default-tag";
            } else if (Math.abs(token.weight) > 1.0) {
              className = "prompt-tag weight-high";
            } else if (Math.abs(token.weight) < 1.0 && token.weight !== 0) {
              className = "prompt-tag weight-low";
            }

            html += `<span class="${className}">${escapeHtml(token.content)}</span>`;

            // åœ¨æ–‡æœ¬tokenåæ·»åŠ ç©ºæ ¼ï¼Œé™¤éä¸‹ä¸€ä¸ªtokenæ˜¯é€—å·æˆ–æƒé‡æ ‡è®°
            if (index < tokens.length - 1) {
              const nextToken = tokens[index + 1];
              if (nextToken.type !== "comma" && nextToken.type !== "weight-marker") {
                html += " ";
              }
            }
          }
        });

        return html;
      }

      // HTMLè½¬ä¹‰å‡½æ•°
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // PNG Chunk è§£æ
      function extractPngChunks(arrayBuffer) {
        const dataView = new DataView(arrayBuffer);
        const chunks = [];
        let offset = 8; // Skip PNG signature

        while (offset < arrayBuffer.byteLength) {
          const length = dataView.getUint32(offset);
          const type = String.fromCharCode(dataView.getUint8(offset + 4), dataView.getUint8(offset + 5), dataView.getUint8(offset + 6), dataView.getUint8(offset + 7));

          const data = new Uint8Array(arrayBuffer, offset + 8, length);
          chunks.push({ type, data });

          offset += length + 12; // length + type + data + crc
        }

        return chunks;
      }

      function decodePngTextChunk(data, chunkType) {
        if (chunkType === "tEXt") {
          const nullIndex = data.indexOf(0);
          const keyword = new TextDecoder().decode(data.slice(0, nullIndex));
          const text = new TextDecoder().decode(data.slice(nullIndex + 1));
          return { keyword, text };
        } else if (chunkType === "iTXt") {
          // iTXtæ ¼å¼æ›´å¤æ‚ï¼ŒåŒ…å«å‹ç¼©æ ‡å¿—å’Œè¯­è¨€æ ‡ç­¾
          let offset = 0;

          // è¯»å–keyword
          const keywordEnd = data.indexOf(0, offset);
          const keyword = new TextDecoder().decode(data.slice(offset, keywordEnd));
          offset = keywordEnd + 1;

          // è·³è¿‡å‹ç¼©æ ‡å¿—å’Œå‹ç¼©æ–¹æ³•
          offset += 2;

          // è·³è¿‡è¯­è¨€æ ‡ç­¾
          const langEnd = data.indexOf(0, offset);
          offset = langEnd + 1;

          // è·³è¿‡ç¿»è¯‘åçš„keyword
          const transKeywordEnd = data.indexOf(0, offset);
          offset = transKeywordEnd + 1;

          // å‰©ä½™çš„æ˜¯æ–‡æœ¬å†…å®¹
          const text = new TextDecoder().decode(data.slice(offset));

          return { keyword, text };
        }
        return { keyword: "Unknown", text: "" };
      }

      // è§£æNovelAIçš„JSONæ•°æ®
      function parseNovelAIData(details) {
        const result = {
          basic: [],
          prompts: [],
          technical: [],
        };

        // ä¸»Prompt
        if (details.prompt) {
          result.prompts.push({
            label: "ä¸»Prompt",
            value: details.prompt,
            copyable: true,
          });
        }

        // è´Ÿé¢Prompt
        if (details.uc) {
          result.prompts.push({
            label: "è´Ÿé¢Prompt",
            value: details.uc,
            copyable: true,
          });
        }

        // V4 è§’è‰²Prompts - æŒ‰ç…§è§’è‰²é¡ºåºæ˜¾ç¤º
        const charPrompts = [];
        const charNegativePrompts = [];

        if (details.v4_prompt && details.v4_prompt.caption && details.v4_prompt.caption.char_captions) {
          details.v4_prompt.caption.char_captions.forEach((char, index) => {
            if (char.char_caption && char.char_caption.trim()) {
              charPrompts[index] = {
                label: `è§’è‰²${index + 1} Prompt`,
                value: char.char_caption,
                copyable: true,
              };
            }
          });
        }

        if (details.v4_negative_prompt && details.v4_negative_prompt.caption && details.v4_negative_prompt.caption.char_captions) {
          details.v4_negative_prompt.caption.char_captions.forEach((char, index) => {
            if (char.char_caption && char.char_caption.trim()) {
              charNegativePrompts[index] = {
                label: `è§’è‰²${index + 1} è´Ÿé¢Prompt`,
                value: char.char_caption,
                copyable: true,
              };
            }
          });
        }

        // æŒ‰ç…§è§’è‰²é¡ºåºæ·»åŠ Promptå’Œè´Ÿé¢Prompt
        const maxCharIndex = Math.max(charPrompts.length, charNegativePrompts.length);
        for (let i = 0; i < maxCharIndex; i++) {
          if (charPrompts[i]) {
            result.prompts.push(charPrompts[i]);
          }
          if (charNegativePrompts[i]) {
            result.prompts.push(charNegativePrompts[i]);
          }
        }

        // æŠ€æœ¯å‚æ•°
        result.technical.push({
          label: "é‡‡æ ·å™¨",
          value: details.sampler || "Unknown",
        });
        result.technical.push({
          label: "æ­¥æ•°",
          value: details.steps || "Unknown",
        });
        result.technical.push({
          label: "å°ºå¯¸",
          value: `${details.width || "?"} Ã— ${details.height || "?"}`,
        });
        result.technical.push({
          label: "CFG Scale",
          value: details.scale || "Unknown",
        });
        result.technical.push({
          label: "ç§å­",
          value: details.seed || "Unknown",
        });
        if (details.noise_schedule) {
          result.technical.push({
            label: "å™ªå£°è®¡åˆ’",
            value: details.noise_schedule,
          });
        }
        if (details.cfg_rescale !== undefined) {
          result.technical.push({
            label: "CFG Rescale",
            value: details.cfg_rescale,
          });
        }
        if (details.strength !== undefined) {
          result.technical.push({
            label: "Strength",
            value: details.strength,
          });
        }
        if (details.noise !== undefined) {
          result.technical.push({
            label: "Noise",
            value: details.noise,
          });
        }
        if (details.generation_time !== undefined) {
          result.technical.push({
            label: "ç”Ÿæˆæ—¶é—´",
            value: `${details.generation_time.toFixed(4)}s`,
          });
        }
        if (details.request_type) {
          result.technical.push({
            label: "è¯·æ±‚ç±»å‹",
            value: details.request_type,
            wide: true,
          });
        }

        return result;
      }

      // å¤„ç†WebUIæ ¼å¼
      function parseWebUIData(text) {
        const result = {
          prompts: [],
          technical: [],
        };

        const parts = text.split("Steps: ");
        if (parts.length >= 2) {
          const promptPart = parts[0];
          const paramsPart = "Steps: " + parts[1];

          const promptSplit = promptPart.split("Negative prompt: ");

          result.prompts.push({
            label: "æ­£é¢æç¤ºè¯",
            value: promptSplit[0].trim(),
            copyable: true,
          });

          if (promptSplit.length > 1) {
            result.prompts.push({
              label: "è´Ÿé¢æç¤ºè¯",
              value: promptSplit[1].trim(),
              copyable: true,
            });
          }

          // è§£æå‚æ•°
          const params = paramsPart.match(/(\w+[\s\w]*): ([^,]+)/g);
          if (params) {
            params.forEach((param) => {
              const [key, value] = param.split(": ");
              result.technical.push({
                label: key,
                value: value,
              });
            });
          }
        }

        return result;
      }

      // æ¸²æŸ“æŠ€æœ¯å‚æ•°åˆ°å·¦ä¾§
      function renderTechnicalParams(technicalData) {
        const technicalPanel = document.getElementById("technicalPanel");
        const technicalParams = document.getElementById("technicalParams");

        if (technicalData && technicalData.length > 0) {
          technicalParams.innerHTML = "";

          technicalData.forEach((item) => {
            const paramEl = document.createElement("div");
            paramEl.className = "tech-param-item";
            if (item.wide) {
              paramEl.classList.add("wide");
            }

            const labelEl = document.createElement("div");
            labelEl.className = "tech-param-label";
            labelEl.textContent = item.label;

            const valueEl = document.createElement("div");
            valueEl.className = "tech-param-value";
            valueEl.textContent = item.value.toString();

            // æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
            paramEl.addEventListener("click", () => {
              copyToClipboard(item.value.toString());
            });

            paramEl.appendChild(labelEl);
            paramEl.appendChild(valueEl);
            technicalParams.appendChild(paramEl);
          });

          technicalPanel.style.display = "block";
        } else {
          technicalPanel.style.display = "none";
        }
      }

      // æ¸²æŸ“ä¿¡æ¯åˆ°å³ä¾§ï¼ˆä¸åŒ…æ‹¬æŠ€æœ¯å‚æ•°ï¼‰
      function renderInfo(data) {
        const container = document.getElementById("infoContainer");
        container.innerHTML = "";

        // Prompts - è¿‡æ»¤æ‰ä¸éœ€è¦çš„å­—æ®µ
        if (data.prompts && data.prompts.length > 0) {
          const filteredPrompts = data.prompts.filter((item) => {
            const label = item.label.toLowerCase();
            return !label.includes("title") && !label.includes("description") && !label.includes("åŸºç¡€caption") && !label.includes("è´Ÿé¢åŸºç¡€caption") && !label.includes("generation_time");
          });

          if (filteredPrompts.length > 0) {
            const section = createSection("Prompts", "âœ¨", filteredPrompts);
            container.appendChild(section);
          }
        }

        // EXIFä¿¡æ¯
        if (data.exif && data.exif.length > 0) {
          const section = createSection("EXIFä¿¡æ¯", "ğŸ“·", data.exif);
          container.appendChild(section);
        }
      }

      function createSection(title, icon, items) {
        const section = document.createElement("div");
        section.className = "info-section";

        const titleEl = document.createElement("h2");
        titleEl.className = "section-title";
        titleEl.innerHTML = `<span class="section-icon">${icon}</span>${title}`;
        section.appendChild(titleEl);

        items.forEach((item, index) => {
          const itemEl = document.createElement("div");
          itemEl.className = "info-item";
          itemEl.style.animationDelay = `${index * 0.1}s`;

          const labelEl = document.createElement("div");
          labelEl.className = "info-label";

          const labelText = document.createElement("span");
          labelText.textContent = item.label;
          labelEl.appendChild(labelText);

          // æ£€æŸ¥æ˜¯å¦ä¸ºpromptç›¸å…³å†…å®¹
          const isPrompt = item.label.toLowerCase().includes("prompt") || item.label.toLowerCase().includes("caption") || item.label.toLowerCase() === "description";

          if (item.copyable) {
            const copyBtn = document.createElement("button");
            copyBtn.className = "copy-btn";
            copyBtn.textContent = "å¤åˆ¶";

            // å¯¹äºpromptç±»å‹ï¼Œå¤åˆ¶æ ¼å¼åŒ–åçš„æ–‡æœ¬ï¼›å¯¹äºå…¶ä»–ç±»å‹ï¼Œå¤åˆ¶åŸå§‹æ–‡æœ¬
            if (isPrompt && item.value && typeof item.value === "string") {
              const formattedText = formatPrompt(item.value);
              copyBtn.onclick = () => copyToClipboard(formattedText);
            } else {
              copyBtn.onclick = () => copyToClipboard(item.value);
            }

            labelEl.appendChild(copyBtn);
          }

          itemEl.appendChild(labelEl);

          const valueEl = document.createElement("div");
          valueEl.className = "info-value";

          if (isPrompt && item.value && typeof item.value === "string") {
            // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿé¢prompt
            const isNegativePrompt = item.label.toLowerCase().includes("è´Ÿé¢") || item.label.toLowerCase().includes("negative");

            // å¯¹promptå†…å®¹è¿›è¡Œæ ¼å¼åŒ–å’Œé«˜äº®
            valueEl.classList.add("formatted-prompt");
            valueEl.innerHTML = renderHighlightedPrompt(item.value, isNegativePrompt);
          } else {
            // æ™®é€šæ–‡æœ¬å†…å®¹
            valueEl.textContent = item.value;
          }

          itemEl.appendChild(valueEl);

          section.appendChild(itemEl);
        });

        return section;
      }

      // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆå’ŒåŸºæœ¬ä¿¡æ¯
      function showImagePreview(file, modelInfo = null) {
        const uploadArea = document.getElementById("uploadArea");
        const uploadContent = document.getElementById("uploadContent");
        const previewImage = document.getElementById("previewImage");
        const imageInfo = document.getElementById("imageInfo");
        const imageFilename = document.getElementById("imageFilename");
        const imageDetails = document.getElementById("imageDetails");

        // è¯»å–å›¾ç‰‡å¹¶æ˜¾ç¤ºé¢„è§ˆ
        const reader = new FileReader();
        reader.onload = (e) => {
          previewImage.src = e.target.result;
          previewImage.style.display = "block";

          // éšè—ä¸Šä¼ æç¤ºï¼Œæ˜¾ç¤ºå›¾ç‰‡ä¿¡æ¯
          uploadContent.style.display = "none";
          uploadArea.classList.add("has-image");

          // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
          // è®¡ç®—å¯ç”¨å®½åº¦ï¼Œå¤§çº¦æ˜¯å®¹å™¨å®½åº¦å‡å»padding
          const maxWidth = 250; // ä¼°ç®—çš„æœ€å¤§å®½åº¦
          const displayFilename = truncateFilename(file.name, maxWidth);
          imageFilename.textContent = displayFilename;
          imageFilename.title = file.name; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºå®Œæ•´æ–‡ä»¶å

          // æ·»åŠ ç‚¹å‡»å¤åˆ¶å®Œæ•´æ–‡ä»¶ååŠŸèƒ½
          imageFilename.onclick = () => {
            copyToClipboard(file.name);
          };

          // æ„å»ºè¯¦ç»†ä¿¡æ¯ï¼Œå¦‚æœæœ‰æ¨¡å‹ä¿¡æ¯å°±æ˜¾ç¤ºæ¨¡å‹ï¼Œå¦åˆ™æ˜¾ç¤ºæ–‡ä»¶ç±»å‹
          const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">${modelInfo ? "æ¨¡å‹:" : "ç±»å‹:"}</span>
                        <span class="detail-value">${modelInfo || file.type}</span>
                    </span>
                `;
          imageDetails.innerHTML = detailsHtml;
          imageInfo.style.display = "block";
        };
        reader.readAsDataURL(file);
      }

      // æ›´æ–°å›¾ç‰‡ä¿¡æ¯ä¸­çš„æ¨¡å‹æ˜¾ç¤º
      function updateImageModelInfo(modelInfo) {
        const imageDetails = document.getElementById("imageDetails");
        const file = window.currentFile; // éœ€è¦ä¿å­˜å½“å‰æ–‡ä»¶å¼•ç”¨

        if (imageDetails && modelInfo && file) {
          const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">æ¨¡å‹:</span>
                        <span class="detail-value">${modelInfo}</span>
                    </span>
                `;
          imageDetails.innerHTML = detailsHtml;
        }
      }

      // å¤„ç†å›¾ç‰‡
      async function processImage(file) {
        const rightPanel = document.getElementById("rightPanel");

        // ä¿å­˜å½“å‰æ–‡ä»¶å¼•ç”¨ç”¨äºåç»­æ›´æ–°
        window.currentFile = file;

        // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
        showImagePreview(file);

        // è¯»å–å…ƒæ•°æ®
        const arrayBuffer = await file.arrayBuffer();
        let allData = {
          basic: [
            {
              label: "æ–‡ä»¶å",
              value: file.name,
            },
            {
              label: "æ–‡ä»¶å¤§å°",
              value: formatFileSize(file.size),
            },
          ],
          prompts: [],
          technical: [],
          exif: [],
        };

        let modelInfo = null;

        // å°è¯•è¯»å–PNG chunks
        if (file.type === "image/png") {
          try {
            const chunks = extractPngChunks(arrayBuffer);
            const textChunks = chunks.filter((chunk) => chunk.type === "tEXt" || chunk.type === "iTXt");

            for (const chunk of textChunks) {
              const decoded = decodePngTextChunk(chunk.data, chunk.type);

              if (decoded.keyword === "parameters") {
                // WebUIæ ¼å¼
                const webUIData = parseWebUIData(decoded.text);
                allData.prompts = [...allData.prompts, ...webUIData.prompts];
                allData.technical = [...allData.technical, ...webUIData.technical];
              } else if (decoded.keyword === "Comment") {
                // å¯èƒ½æ˜¯NovelAIæ ¼å¼
                try {
                  const jsonData = JSON.parse(decoded.text);
                  console.log("NovelAI JSON data:", jsonData);
                  const novelAIData = parseNovelAIData(jsonData);
                  allData.prompts = [...allData.prompts, ...novelAIData.prompts];
                  allData.technical = [...allData.technical, ...novelAIData.technical];
                } catch (e) {
                  // ä¸æ˜¯JSONï¼Œä½œä¸ºæ™®é€šæ–‡æœ¬å¤„ç†
                  allData.prompts.push({
                    label: decoded.keyword,
                    value: decoded.text,
                    copyable: true,
                  });
                }
              } else if (decoded.keyword === "Software") {
                // NovelAIè½¯ä»¶ä¿¡æ¯
                allData.basic.push({
                  label: "è½¯ä»¶",
                  value: decoded.text,
                });
              } else if (decoded.keyword === "Source") {
                // æ¨¡å‹ä¿¡æ¯
                modelInfo = decoded.text;
                allData.basic.push({
                  label: "æ¨¡å‹",
                  value: decoded.text,
                });
              } else {
                allData.prompts.push({
                  label: decoded.keyword,
                  value: decoded.text,
                  copyable: true,
                });
              }
            }
          } catch (e) {
            console.error("è§£æPNGå¤±è´¥:", e);
          }
        }

        // è¯»å–EXIF
        EXIF.getData(file, function () {
          const allTags = EXIF.getAllTags(this);

          // æ£€æŸ¥æ˜¯å¦æ˜¯NovelAIå›¾ç‰‡
          let isNovelAI = false;
          let novelAIExifData = {};

          for (const tag in allTags) {
            const value = allTags[tag];

            // ç‰¹æ®Šå¤„ç†NovelAIçš„EXIFå­—æ®µ
            if (tag === "Software" && value.toString().includes("NovelAI")) {
              isNovelAI = true;
              allData.basic.splice(1, 0, {
                label: "è½¯ä»¶",
                value: value.toString(),
              });
            } else if (tag === "Model" || tag === "EquipModel") {
              modelInfo = value.toString();
              allData.basic.splice(2, 0, {
                label: "æ¨¡å‹",
                value: value.toString(),
              });
            } else if (tag === "UserComment") {
              // UserCommentå¯èƒ½åŒ…å«JSONæ•°æ®
              try {
                const text = value.toString();
                // å»é™¤å¯èƒ½çš„Unicodeå­—ç¬¦
                const cleanText = text.replace(/[\x00-\x1F\x7F-\x9F]/g, "").trim();
                if (cleanText.startsWith("{")) {
                  const jsonData = JSON.parse(cleanText);
                  console.log("EXIF UserComment JSON:", jsonData);
                  const novelAIData = parseNovelAIData(jsonData);
                  // å¦‚æœè¿˜æ²¡æœ‰è¿™äº›æ•°æ®ï¼Œæ·»åŠ å®ƒä»¬
                  if (allData.prompts.length === 0) {
                    allData.prompts = [...novelAIData.prompts];
                    allData.technical = [...novelAIData.technical];
                  }
                }
              } catch (e) {
                // ä¸æ˜¯JSONï¼Œæ·»åŠ ä¸ºæ™®é€šEXIF
                if (tag !== "thumbnail") {
                  allData.exif.push({
                    label: tag,
                    value: value.toString(),
                  });
                }
              }
            } else if (tag !== "thumbnail" && tag !== "undefined") {
              // å…¶ä»–EXIFä¿¡æ¯
              allData.exif.push({
                label: tag,
                value: value.toString(),
              });
            }
          }

          // å¦‚æœæ‰¾åˆ°äº†æ¨¡å‹ä¿¡æ¯ï¼Œæ›´æ–°å›¾ç‰‡æ˜¾ç¤ºä¸­çš„æ¨¡å‹ä¿¡æ¯
          if (modelInfo) {
            updateImageModelInfo(modelInfo);
          }

          // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å…ƒæ•°æ®
          if (allData.prompts.length === 0 && allData.technical.length === 0) {
            allData.prompts.push({
              label: "æç¤º",
              value: "æœªæ‰¾åˆ°AIç”Ÿæˆå‚æ•°ã€‚è¿™å¯èƒ½ä¸æ˜¯AIç”Ÿæˆçš„å›¾ç‰‡ï¼Œæˆ–è€…å…ƒæ•°æ®å·²è¢«åˆ é™¤ã€‚",
            });
          }

          // æ¸²æŸ“æŠ€æœ¯å‚æ•°åˆ°å·¦ä¾§
          renderTechnicalParams(allData.technical);

          // æ¸²æŸ“å…¶ä»–ä¿¡æ¯åˆ°å³ä¾§
          renderInfo(allData);
          rightPanel.style.display = "block";
        });
      }

      // åˆå§‹åŒ–ä¸Šä¼ åŠŸèƒ½
      document.addEventListener("DOMContentLoaded", () => {
        const uploadArea = document.getElementById("uploadArea");
        const fileInput = document.getElementById("fileInput");
        const uploadContent = document.getElementById("uploadContent");
        const previewImage = document.getElementById("previewImage");
        const imageInfo = document.getElementById("imageInfo");
        const technicalPanel = document.getElementById("technicalPanel");
        const rightPanel = document.getElementById("rightPanel");

        // é‡ç½®ç•Œé¢çš„å‡½æ•°
        function resetInterface() {
          uploadArea.classList.remove("has-image");
          uploadContent.style.display = "flex";
          previewImage.style.display = "none";
          imageInfo.style.display = "none";
          technicalPanel.style.display = "none";
          rightPanel.style.display = "none";
          window.currentFile = null;

          // æ¸…é™¤æ–‡ä»¶åçš„ç‚¹å‡»äº‹ä»¶
          const imageFilename = document.getElementById("imageFilename");
          if (imageFilename) {
            imageFilename.onclick = null;
            imageFilename.title = "";
          }
        }

        uploadArea.addEventListener("click", (e) => {
          // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œè¯¢é—®æ˜¯å¦è¦é€‰æ‹©æ–°å›¾ç‰‡
          if (e.target.tagName === "IMG" && e.target.id === "previewImage") {
            if (confirm("è¦é€‰æ‹©æ–°çš„å›¾ç‰‡å—ï¼Ÿ")) {
              resetInterface();
              fileInput.click();
            }
          } else if (!uploadArea.classList.contains("has-image")) {
            // å¦‚æœè¿˜æ²¡æœ‰å›¾ç‰‡ï¼Œç›´æ¥æ‰“å¼€é€‰æ‹©
            fileInput.click();
          }
        });

        fileInput.addEventListener("change", (e) => {
          const file = e.target.files[0];
          if (file && file.type.startsWith("image/")) {
            processImage(file);
          }
          // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
          fileInput.value = "";
        });

        // æ‹–æ‹½åŠŸèƒ½
        uploadArea.addEventListener("dragover", (e) => {
          e.preventDefault();
          uploadArea.classList.add("drag-over");
        });

        uploadArea.addEventListener("dragleave", () => {
          uploadArea.classList.remove("drag-over");
        });

        uploadArea.addEventListener("drop", (e) => {
          e.preventDefault();
          uploadArea.classList.remove("drag-over");

          const file = e.dataTransfer.files[0];
          if (file && file.type.startsWith("image/")) {
            processImage(file);
          }
        });
      });
    </script>
  </body>
</html>
