<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NovelAI å›¾ç‰‡è§£æ</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background-color: #f5f7fa;
      color: #333;
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      position: relative;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      font-weight: 700;
    }

    .header p {
      font-size: 1.1rem;
      opacity: 0.9;
    }

    .header-controls {
      position: absolute;
      top: 20px;
      right: 20px;
    }

    .settings-btn {
      background: rgba(255, 255, 255, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.3);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .main-content {
      display: grid;
      grid-template-columns: 2fr 3fr;
      gap: 30px;
      align-items: start;
    }

    @media (max-width: 968px) {
      .main-content {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .left-column {
        margin-bottom: 0;
      }

      .technical-panel {
        margin-bottom: 0;
      }

      .right-panel {
        margin-top: 0;
      }
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .left-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .technical-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .upload-area {
      border: 3px dashed #e0e6ed;
      border-radius: 12px;
      padding: 60px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      background: #f8f9fc;
      width: 100%;
      min-height: 350px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }

    .upload-area:hover {
      border-color: #667eea;
      background: #f0f2ff;
    }

    .upload-area.drag-over {
      border-color: #667eea;
      background: #e8ebff;
      transform: scale(1.02);
    }

    .upload-area.has-image {
      padding: 20px;
      background: #fff;
      cursor: default;
      min-height: auto;
      border-color: #d0d7de;
    }

    .upload-area.has-image:hover {
      background: #f8f9fc;
      border-color: #667eea;
    }

    .upload-area.has-image .preview-image {
      cursor: pointer;
    }

    .image-info-compact {
      text-align: center;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e8ebf4;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      width: 100%;
    }

    .image-info-compact .image-filename {
      font-size: 0.95rem;
      color: #333;
      font-weight: 500;
      margin-bottom: 5px;
      white-space: nowrap;
      overflow: hidden;
      cursor: pointer;
      transition: color 0.2s ease;
    }

    .image-info-compact .image-filename:hover {
      color: #667eea;
    }

    .image-info-compact .image-details {
      font-size: 0.85rem;
      color: #666;
      cursor: help;
    }

    .section-icon {
      color: #667eea;
    }

    #uploadContent {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .upload-icon {
      font-size: 48px;
      color: #667eea;
      margin-bottom: 20px;
    }

    .upload-text {
      color: #666;
      font-size: 1.1rem;
      margin-bottom: 10px;
    }

    .upload-hint {
      color: #999;
      font-size: 0.9rem;
    }

    .preview-image {
      max-width: 100%;
      max-height: 350px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      display: block;
      margin: 0 auto;
      cursor: pointer;
    }

    .preview-image:hover {
      box-shadow: 0 6px 25px rgba(0, 0, 0, 0.15);
    }

    .image-filename {
      font-size: 1.1rem;
      font-weight: 500;
      color: #333;
      margin-bottom: 10px;
      word-break: break-all;
    }

    .image-details {
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .detail-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
      color: #666;
    }

    .detail-label {
      color: #999;
    }

    .detail-value {
      color: #333;
      font-weight: 500;
    }

    .right-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
      max-height: 90vh;
      overflow-y: auto;
    }

    .info-section {
      margin-bottom: 30px;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 600;
      margin-bottom: 20px;
      color: #444;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-item {
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 15px;
      border: 1px solid #e8ebf4;
      transition: all 0.3s ease;
    }

    .info-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }

    .info-label {
      font-weight: 600;
      color: #555;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .info-value {
      color: #666;
      line-height: 1.6;
      word-break: break-word;
      white-space: pre-wrap;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.9rem;
    }

    .info-value.formatted-prompt {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      font-size: 0.95rem;
      line-height: 1.7;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    /* Promptæƒé‡é«˜äº®æ ·å¼ */
    .prompt-tag {
      display: inline;
    }

    .prompt-tag.weight-high {
      color: #e53e3e;
    }

    .prompt-tag.weight-low {
      color: #3182ce;
    }

    .prompt-tag.weight-normal {
      color: #333;
    }

    .prompt-tag.default-tag {
      color: #a0aec0;
      opacity: 0.7;
    }

    .prompt-weight-marker {
      color: #805ad5;
      font-weight: 600;
      opacity: 0.8;
      white-space: nowrap;
    }

    .prompt-comma {
      color: #a0aec0;
    }

    .tech-params {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      background: #f8f9fc;
      border-radius: 12px;
      padding: 20px;
      border: 1px solid #e8ebf4;
    }

    @media (max-width: 768px) {
      .tech-params {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 12px;
        padding: 15px;
      }
    }

    .tech-param-item {
      display: flex;
      flex-direction: column;
      gap: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
      padding: 8px;
      border-radius: 6px;
      overflow-wrap: break-word;
    }

    .tech-param-item:hover {
      background-color: rgba(102, 126, 234, 0.1);
    }

    .tech-param-item.wide {
      grid-column: span 2;
    }

    .tech-param-label {
      font-size: 0.85rem;
      color: #888;
      font-weight: 500;
    }

    .tech-param-value {
      font-size: 0.95rem;
      color: #333;
      font-weight: 600;
      font-family: "Monaco", "Consolas", monospace;
    }

    .copy-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.3s ease;
    }

    .copy-btn:hover {
      background: #5a67d8;
      transform: translateY(-1px);
    }

    .copy-btn:active {
      transform: translateY(0);
    }

    .json-viewer {
      background: #f5f7fa;
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      font-family: "Monaco", "Consolas", monospace;
      font-size: 0.85rem;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #999;
    }

    .error {
      background: #fee;
      color: #c33;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }

    .footer {
      text-align: center;
      margin-top: 50px;
      padding: 20px;
      color: #999;
      font-size: 0.9rem;
      clear: both;
    }

    .footer a {
      color: #667eea;
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* æ»šåŠ¨æ¡æ ·å¼ */
    .right-panel::-webkit-scrollbar {
      width: 8px;
    }

    .right-panel::-webkit-scrollbar-track {
      background: #f1f1f1;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 4px;
    }

    .right-panel::-webkit-scrollbar-thumb:hover {
      background: #999;
    }

    /* åŠ¨ç”» */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .info-item {
      animation: fadeIn 0.5s ease;
    }

    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #667eea;
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    /* è®¾ç½®é¢æ¿æ ·å¼ */
    .settings-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      backdrop-filter: blur(5px);
    }

    .settings-modal.show {
      display: flex;
    }

    .settings-panel {
      background: white;
      border-radius: 16px;
      padding: 30px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.2);
      animation: modalSlideIn 0.3s ease;
    }

    @keyframes modalSlideIn {
      from {
        opacity: 0;
        transform: translateY(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 1px solid #e8ebf4;
    }

    .settings-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #333;
    }

    .close-btn {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: #999;
      padding: 5px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .close-btn:hover {
      background: #f0f0f0;
      color: #666;
    }

    .setting-group {
      margin-bottom: 25px;
    }

    .setting-label {
      display: block;
      font-weight: 600;
      color: #555;
      margin-bottom: 8px;
      font-size: 0.95rem;
    }

    .setting-input {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid #e0e6ed;
      border-radius: 8px;
      font-size: 0.95rem;
      transition: all 0.3s ease;
    }

    .setting-input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .setting-description {
      font-size: 0.85rem;
      color: #666;
      margin-top: 5px;
      line-height: 1.4;
    }

    .setting-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 26px;
      background: #ddd;
      border-radius: 13px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .toggle-switch.active {
      background: #667eea;
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      transition: transform 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .toggle-switch.active .toggle-slider {
      transform: translateX(24px);
    }

    .save-btn {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 500;
      transition: all 0.3s ease;
      width: 100%;
    }

    .save-btn:hover {
      background: #5a67d8;
      transform: translateY(-1px);
    }

    .save-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .test-btn {
      background: #28a745;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 10px;
    }

    .test-btn:hover {
      background: #218838;
      transform: translateY(-1px);
    }

    .test-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .provider-config {
      border-left: 3px solid #667eea;
      padding-left: 15px;
      margin-left: 10px;
    }

    .test-result {
      margin-top: 15px;
      padding: 12px;
      border-radius: 8px;
      font-size: 0.9rem;
      line-height: 1.4;
    }

    .test-result.success {
      background: #d4edda;
      border: 1px solid #c3e6cb;
      color: #155724;
    }

    .test-result.error {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
    }

    .test-result.loading {
      background: #d1ecf1;
      border: 1px solid #bee5eb;
      color: #0c5460;
    }

    /* ç¿»è¯‘ç›¸å…³æ ·å¼ */
    .prompt-container {
      position: relative;
    }

    .prompt-translation {
      font-size: 0.85rem;
      color: #666;
      font-style: italic;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #f0f0f0;
      line-height: 1.7;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      word-break: break-word;
      overflow-wrap: break-word;
    }

    .translation-loading {
      color: #999;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .translation-error {
      color: #e53e3e;
    }

    /* Tagç¿»è¯‘æ ·å¼ */
    .translation-tag {
      display: inline;
      transition: all 0.2s ease;
      border-radius: 3px;
      padding: 1px 2px;
    }

    .translation-comma {
      color: #a0aec0;
    }

    /* æ‚¬åœé«˜äº®æ•ˆæœ */
    .prompt-tag.highlighted {
      background-color: rgba(102, 126, 234, 0.15);
      transform: scale(1.02);
    }

    .translation-tag.highlighted {
      background-color: rgba(102, 126, 234, 0.15);
      transform: scale(1.02);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #999;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
      <div class="header-controls">
        <button class="settings-btn" id="settingsBtn">âš™ï¸ è®¾ç½®</button>
      </div>
      <h1>ğŸ¨ NovelAI å›¾ç‰‡è§£æ</h1>
      <p>ä» NovelAI ç”Ÿæˆçš„å›¾ç‰‡ä¸­æå–è¯¦ç»†å‚æ•°ä¿¡æ¯</p>
    </div>

    <div class="main-content">
      <div class="left-column">
        <div class="left-panel">
          <div class="upload-area" id="uploadArea">
            <div id="uploadContent">
              <div class="upload-icon">ğŸ“</div>
              <div class="upload-text">æ‹–æ‹½å›¾ç‰‡åˆ°è¿™é‡Œ</div>
              <div class="upload-hint">æˆ–ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
            </div>
            <!-- é¢„è§ˆå›¾ç‰‡ -->
            <img id="previewImage" class="preview-image" style="display: none" alt="é¢„è§ˆå›¾ç‰‡" />
            <!-- åŸºç¡€ä¿¡æ¯ -->
            <div class="image-info-compact" id="imageInfo" style="display: none">
              <div class="image-filename" id="imageFilename"></div>
              <div class="image-details" id="imageDetails"></div>
            </div>
            <input type="file" id="fileInput" accept="image/*" style="display: none" />
          </div>
        </div>

        <!-- æŠ€æœ¯å‚æ•°åŒºåŸŸ -->
        <div class="technical-panel" id="technicalPanel" style="display: none">
          <div id="technicalParams" class="tech-params"></div>
        </div>
      </div>

      <div class="right-panel" id="rightPanel" style="display: none">
        <div id="infoContainer"></div>
      </div>
    </div>

    <div class="footer">
      <p>* æ‰€æœ‰è¿ç®—å®Œå…¨åœ¨æ‚¨çš„è®¾å¤‡ä¸Šè¿è¡Œï¼Œä¸ä¼šä¸Šä¼ åˆ°äº‘ç«¯</p>
      <p>Made by <a href="https://github.com/Natsukage">@Natsukage</a></p>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- è®¾ç½®é¢æ¿ -->
  <div class="settings-modal" id="settingsModal">
    <div class="settings-panel">
      <div class="settings-header">
        <h2 class="settings-title">ğŸ› ï¸ è®¾ç½®</h2>
        <button class="close-btn" id="closeSettingsBtn">Ã—</button>
      </div>
      
      <div class="setting-group">
        <div class="setting-toggle">
          <label class="setting-label">å¯ç”¨AIç¿»è¯‘</label>
          <div class="toggle-switch" id="translationToggle">
            <div class="toggle-slider"></div>
          </div>
        </div>
        <div class="setting-description">
          å¼€å¯åï¼Œå°†è‡ªåŠ¨ç¿»è¯‘æç¤ºè¯ä¸ºä¸­æ–‡ã€‚ç¿»è¯‘ç»“æœä¼šæ˜¾ç¤ºåœ¨åŸæ–‡ä¸‹æ–¹ã€‚<br>
          <small style="color: #666;">â„¹ï¸ é¦–æ¬¡ä½¿ç”¨æ—¶å°†è‡ªåŠ¨ä¸‹è½½ç¿»è¯‘ç¼“å­˜ï¼Œé«˜é¢‘è¯æ±‡æ— éœ€è°ƒç”¨APIã€‚</small>
        </div>
      </div>

      <div class="setting-group">
        <label class="setting-label">ç¿»è¯‘æœåŠ¡æä¾›å•†</label>
        <select id="translationProviderSelect" class="setting-input">
          <option value="gemini">Gemini AIï¼ˆå…CORSé…ç½®ï¼‰</option>
          <option value="tencent">è…¾è®¯äº‘ç¿»è¯‘ï¼ˆéœ€CORSé…ç½®ï¼‰</option>
          <option value="baidu">ç™¾åº¦ç¿»è¯‘ï¼ˆéœ€CORSé…ç½®ï¼‰</option>
        </select>
        <div class="setting-description">
          é€‰æ‹©ç¿»è¯‘æœåŠ¡æä¾›å•†ã€‚Geminié€Ÿåº¦æ…¢ä½†è´¨é‡é«˜ï¼Œè…¾è®¯å’Œç™¾åº¦é€Ÿåº¦å¿«ä¸”æˆæœ¬ä½ï¼Œä½†éœ€è¦é…ç½®è·¨åŸŸæ”¯æŒã€‚
        </div>
      </div>

      <!-- Gemini é…ç½® -->
      <div class="setting-group provider-config" id="geminiConfig">
        <label class="setting-label" for="apiKeyInput">Gemini API Key</label>
        <input type="password" id="apiKeyInput" class="setting-input" placeholder="è¾“å…¥æ‚¨çš„ Gemini API Key">
        <div class="setting-description">
          è¯·è¾“å…¥æ‚¨çš„ Google Gemini API Keyã€‚æ‚¨å¯ä»¥åœ¨ <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> è·å–ã€‚
        </div>
      </div>

      <!-- è…¾è®¯äº‘é…ç½® -->
      <div class="setting-group provider-config" id="tencentConfig" style="display: none;">
        <label class="setting-label" for="tencentSecretIdInput">è…¾è®¯äº‘ Secret ID</label>
        <input type="password" id="tencentSecretIdInput" class="setting-input" placeholder="è¾“å…¥æ‚¨çš„è…¾è®¯äº‘ Secret ID">
        
        <label class="setting-label" for="tencentSecretKeyInput" style="margin-top: 15px;">è…¾è®¯äº‘ Secret Key</label>
        <input type="password" id="tencentSecretKeyInput" class="setting-input" placeholder="è¾“å…¥æ‚¨çš„è…¾è®¯äº‘ Secret Key">
        
        <div class="setting-description">
          è¯·è¾“å…¥æ‚¨çš„è…¾è®¯äº‘è®¿é—®å¯†é’¥ã€‚æ‚¨å¯ä»¥åœ¨ <a href="https://console.cloud.tencent.com/cam/capi" target="_blank">è…¾è®¯äº‘æ§åˆ¶å°</a> è·å–ã€‚
          <br><strong>æ³¨æ„ï¼šä½¿ç”¨å‰è¯·å®‰è£…CORSæ’ä»¶æˆ–Tampermonkeyè„šæœ¬ï¼</strong>
        </div>
      </div>

      <!-- ç™¾åº¦ç¿»è¯‘é…ç½® -->
      <div class="setting-group provider-config" id="baiduConfig" style="display: none;">
        <label class="setting-label" for="baiduAppIdInput">ç™¾åº¦ç¿»è¯‘ App ID</label>
        <input type="text" id="baiduAppIdInput" class="setting-input" placeholder="è¾“å…¥æ‚¨çš„ç™¾åº¦ç¿»è¯‘ App ID">
        
        <label class="setting-label" for="baiduAppKeyInput" style="margin-top: 15px;">ç™¾åº¦ç¿»è¯‘ App Key</label>
        <input type="password" id="baiduAppKeyInput" class="setting-input" placeholder="è¾“å…¥æ‚¨çš„ç™¾åº¦ç¿»è¯‘ App Key">
        
        <div class="setting-description">
          è¯·è¾“å…¥æ‚¨çš„ç™¾åº¦ç¿»è¯‘å¯†é’¥ã€‚æ‚¨å¯ä»¥åœ¨ <a href="https://fanyi-api.baidu.com/api/trans/product/index" target="_blank">ç™¾åº¦ç¿»è¯‘å¼€æ”¾å¹³å°</a> è·å–ã€‚
          <br><strong>æ³¨æ„ï¼šä½¿ç”¨å‰è¯·å®‰è£…CORSæ’ä»¶æˆ–Tampermonkeyè„šæœ¬ï¼</strong>
        </div>
      </div>

      <!-- è¿æ¥æµ‹è¯• -->
      <div class="setting-group">
        <button class="test-btn" id="testConnectionBtn">æµ‹è¯•è¿æ¥</button>
        <div class="setting-description">
          ç‚¹å‡»æµ‹è¯•å½“å‰é€‰æ‹©çš„ç¿»è¯‘æœåŠ¡æ˜¯å¦å¯æ­£å¸¸è®¿é—®ã€‚å¦‚æœæµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥APIå¯†é’¥å’ŒCORSé…ç½®ã€‚
        </div>
        <!-- æµ‹è¯•ç»“æœæ˜¾ç¤º -->
        <div id="testResult" class="test-result" style="display: none;">
          <div id="testResultContent"></div>
        </div>
      </div>

      <button class="save-btn" id="saveSettingsBtn">ä¿å­˜è®¾ç½®</button>
    </div>
  </div>

  <!-- å¼•å…¥å¿…è¦çš„åº“ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <script>
    // =============================================================================
    // å·¥å…·å‡½æ•°æ¨¡å—
    // =============================================================================
    
    // =============================================================================
    // è®¾ç½®ç®¡ç†æ¨¡å—
    // =============================================================================
    
    const SettingsManager = {
      STORAGE_KEYS: {
        API_KEY: 'gemini_api_key',
        TRANSLATION_ENABLED: 'translation_enabled',
        TRANSLATION_PROVIDER: 'translation_provider',
        TENCENT_SECRET_ID: 'tencent_secret_id',
        TENCENT_SECRET_KEY: 'tencent_secret_key',
        BAIDU_APP_ID: 'baidu_app_id',
        BAIDU_APP_KEY: 'baidu_app_key'
      },

      getApiKey() {
        return localStorage.getItem(this.STORAGE_KEYS.API_KEY) || '';
      },

      setApiKey(key) {
        if (key) {
          localStorage.setItem(this.STORAGE_KEYS.API_KEY, key);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.API_KEY);
        }
      },

      isTranslationEnabled() {
        return localStorage.getItem(this.STORAGE_KEYS.TRANSLATION_ENABLED) === 'true';
      },

      setTranslationEnabled(enabled) {
        localStorage.setItem(this.STORAGE_KEYS.TRANSLATION_ENABLED, enabled.toString());
      },

      hasValidApiKey() {
        const key = this.getApiKey();
        return key && key.length > 0;
      },

      // ç¿»è¯‘æœåŠ¡æä¾›å•†ç®¡ç†
      getTranslationProvider() {
        return localStorage.getItem(this.STORAGE_KEYS.TRANSLATION_PROVIDER) || 'gemini';
      },

      setTranslationProvider(provider) {
        localStorage.setItem(this.STORAGE_KEYS.TRANSLATION_PROVIDER, provider);
      },

      // è…¾è®¯äº‘é…ç½®ç®¡ç†
      getTencentSecretId() {
        return localStorage.getItem(this.STORAGE_KEYS.TENCENT_SECRET_ID) || '';
      },

      setTencentSecretId(secretId) {
        if (secretId) {
          localStorage.setItem(this.STORAGE_KEYS.TENCENT_SECRET_ID, secretId);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.TENCENT_SECRET_ID);
        }
      },

      getTencentSecretKey() {
        return localStorage.getItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY) || '';
      },

      setTencentSecretKey(secretKey) {
        if (secretKey) {
          localStorage.setItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY, secretKey);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.TENCENT_SECRET_KEY);
        }
      },

      // ç™¾åº¦ç¿»è¯‘é…ç½®ç®¡ç†
      getBaiduAppId() {
        return localStorage.getItem(this.STORAGE_KEYS.BAIDU_APP_ID) || '';
      },

      setBaiduAppId(appId) {
        if (appId) {
          localStorage.setItem(this.STORAGE_KEYS.BAIDU_APP_ID, appId);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.BAIDU_APP_ID);
        }
      },

      getBaiduAppKey() {
        return localStorage.getItem(this.STORAGE_KEYS.BAIDU_APP_KEY) || '';
      },

      setBaiduAppKey(appKey) {
        if (appKey) {
          localStorage.setItem(this.STORAGE_KEYS.BAIDU_APP_KEY, appKey);
        } else {
          localStorage.removeItem(this.STORAGE_KEYS.BAIDU_APP_KEY);
        }
      },

      // æ£€æŸ¥å„æœåŠ¡çš„é…ç½®æœ‰æ•ˆæ€§
      hasValidGeminiConfig() {
        const key = this.getApiKey();
        return key && key.length > 0;
      },

      hasValidTencentConfig() {
        const secretId = this.getTencentSecretId();
        const secretKey = this.getTencentSecretKey();
        return secretId && secretId.length > 0 && secretKey && secretKey.length > 0;
      },

      hasValidBaiduConfig() {
        const appId = this.getBaiduAppId();
        const appKey = this.getBaiduAppKey();
        return appId && appId.length > 0 && appKey && appKey.length > 0;
      },

      hasValidCurrentProviderConfig() {
        const provider = this.getTranslationProvider();
        switch (provider) {
          case 'gemini':
            return this.hasValidGeminiConfig();
          case 'tencent':
            return this.hasValidTencentConfig();
          case 'baidu':
            return this.hasValidBaiduConfig();
          default:
            return false;
        }
      }
    };

    // =============================================================================
    // Gemini API ç¿»è¯‘æ¨¡å—
    // =============================================================================
    
    const GeminiTranslator = {
      API_ENDPOINT: 'https://generativelanguage.googleapis.com/v1beta/models',
      MODEL: 'gemini-2.5-flash',

      async translateTags(tagsArray) {
        const apiKey = SettingsManager.getApiKey();
        if (!apiKey || !SettingsManager.isTranslationEnabled()) {
          return [];
        }

        try {
          // è¿‡æ»¤æ‰ç©ºæ ‡ç­¾å’Œæƒé‡æ ‡è®°
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const promptText = `ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„AIç»˜ç”»æç¤ºè¯ç¿»è¯‘åŠ©æ‰‹ã€‚æˆ‘ä¼šç»™ä½ ä¸€ä¸ªè‹±æ–‡AIç»˜ç”»æ ‡ç­¾(tags)çš„æ•°ç»„ï¼Œè¯·å°†æ¯ä¸ªæ ‡ç­¾ç¿»è¯‘æˆä¸­æ–‡ã€‚

è¦æ±‚ï¼š
1. ä¿æŒä¸“ä¸šæœ¯è¯­çš„å‡†ç¡®æ€§
2. å°½é‡ä¿æŒåŸæ„ï¼Œå¯¹äºè‰ºæœ¯å®¶åç­‰ä¸è¦ç¿»è¯‘ã€‚
3. ç¿»è¯‘è¦ç®€æ´å‡†ç¡®ä¸”æ˜“æ‡‚ï¼Œä¾‹å¦‚å¯¹äºdutch angleç­‰æœ¯è¯­ï¼Œéœ€è¦ç¿»è¯‘ä¸ºæ–œè§’é•œå¤´ç­‰æ˜“æ‡‚çš„è¯æ±‡
4. ç›´æ¥è¿”å›ç¿»è¯‘åçš„æ•°ç»„ï¼Œæ ¼å¼å¦‚ï¼š["ç¿»è¯‘1", "ç¿»è¯‘2", "ç¿»è¯‘3"]

è¯·åªè¿”å›JSONæ•°ç»„ï¼Œä¸è¦åŒ…å«å…¶ä»–å†…å®¹ã€‚

éœ€è¦ç¿»è¯‘çš„æ ‡ç­¾æ•°ç»„ï¼š
${JSON.stringify(validTags)}`;

          const requestBody = {
            contents: [
              {
                role: "user",
                parts: [
                  {
                    text: promptText
                  }
                ]
              }
            ],
            generationConfig: {
              responseMimeType: "text/plain",
              temperature: 0.2
            }
          };

          const response = await fetch(`${this.API_ENDPOINT}/${this.MODEL}:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody)
          });

          if (!response.ok) {
            throw new Error(`APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
          }

          const data = await response.json();
          const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
          
          if (!content) {
            throw new Error('APIè¿”å›å†…å®¹ä¸ºç©º');
          }

          // è§£æJSONå“åº”
          let translations;
          try {
            translations = JSON.parse(content.trim());
          } catch (e) {
            // å¦‚æœä¸æ˜¯JSONæ ¼å¼ï¼Œå°è¯•æå–JSONæ•°ç»„éƒ¨åˆ†
            const jsonMatch = content.match(/\[[\s\S]*\]/);
            if (jsonMatch) {
              translations = JSON.parse(jsonMatch[0]);
            } else {
              throw new Error('æ— æ³•è§£æç¿»è¯‘ç»“æœ');
            }
          }

          if (!Array.isArray(translations)) {
            throw new Error('ç¿»è¯‘ç»“æœæ ¼å¼é”™è¯¯');
          }

          return translations;

        } catch (error) {
          console.error('ç¿»è¯‘å¤±è´¥:', error);
          showToast(`ç¿»è¯‘å¤±è´¥: ${error.message}`);
          return [];
        }
      }
    };

    // =============================================================================
    // ç¿»è¯‘æœåŠ¡æä¾›å•†æšä¸¾å’Œå·¥å…·å‡½æ•°
    // =============================================================================
    
    const TranslationProviders = {
      GEMINI: 'gemini',
      TENCENT: 'tencent',
      BAIDU: 'baidu'
    };

    // å·¥å…·å‡½æ•°ï¼šåŠ å¯†å’Œç­¾å
    const CryptoUtils = {
      // SHA256 å“ˆå¸Œå‡½æ•°
      async sha256(message) {
        const msgBuffer = new TextEncoder().encode(message);
        const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      },

      // HMAC-SHA256 ç­¾åå‡½æ•°
      async hmacSha256(key, message) {
        let keyData, messageData;
        
        // å¦‚æœkeyæ˜¯å­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„ï¼›å¦‚æœæ˜¯hexå­—ç¬¦ä¸²ï¼Œå…ˆè½¬æ¢ä¸ºäºŒè¿›åˆ¶
        if (typeof key === 'string') {
          if (key.match(/^[0-9a-fA-F]+$/) && key.length % 2 === 0 && key.length > 10) {
            // è¿™æ˜¯ä¸€ä¸ªhexå­—ç¬¦ä¸²ï¼Œè½¬æ¢ä¸ºäºŒè¿›åˆ¶
            keyData = new Uint8Array(key.match(/.{2}/g).map(byte => parseInt(byte, 16)));
          } else {
            // è¿™æ˜¯æ™®é€šå­—ç¬¦ä¸²
            keyData = new TextEncoder().encode(key);
          }
        } else {
          keyData = key;
        }
        
        messageData = new TextEncoder().encode(message);
        
        const cryptoKey = await crypto.subtle.importKey(
          'raw',
          keyData,
          { name: 'HMAC', hash: 'SHA-256' },
          false,
          ['sign']
        );
        
        const signature = await crypto.subtle.sign('HMAC', cryptoKey, messageData);
        const hashArray = Array.from(new Uint8Array(signature));
        return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
      },

      // MD5 å“ˆå¸Œå‡½æ•°ï¼ˆç”¨äºç™¾åº¦ç¿»è¯‘ï¼‰
      md5(str) {
        function rotateLeft(value, amount) {
          return (value << amount) | (value >>> (32 - amount));
        }

        function addUnsigned(x, y) {
          const x4 = (x & 0x40000000);
          const y4 = (y & 0x40000000);
          const x8 = (x & 0x80000000);
          const y8 = (y & 0x80000000);
          const result = (x & 0x3FFFFFFF) + (y & 0x3FFFFFFF);
          if (x4 & y4) {
            return (result ^ 0x80000000 ^ x8 ^ y8);
          }
          if (x4 | y4) {
            if (result & 0x40000000) {
              return (result ^ 0xC0000000 ^ x8 ^ y8);
            } else {
              return (result ^ 0x40000000 ^ x8 ^ y8);
            }
          } else {
            return (result ^ x8 ^ y8);
          }
        }

        function f(x, y, z) {
          return (x & y) | ((~x) & z);
        }

        function g(x, y, z) {
          return (x & z) | (y & (~z));
        }

        function h(x, y, z) {
          return (x ^ y ^ z);
        }

        function i(x, y, z) {
          return (y ^ (x | (~z)));
        }

        function ff(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(f(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function gg(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(g(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function hh(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(h(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function ii(a, b, c, d, x, s, ac) {
          a = addUnsigned(a, addUnsigned(addUnsigned(i(b, c, d), x), ac));
          return addUnsigned(rotateLeft(a, s), b);
        }

        function convertToWordArray(str) {
          let wordArray = [];
          let messageLength = str.length;
          let numberOfWords = (((messageLength + 8) - ((messageLength + 8) % 64)) / 64 + 1) * 16;
          
          for (let i = 0; i < numberOfWords; i++) {
            wordArray[i] = 0;
          }
          
          for (let i = 0; i < messageLength; i++) {
            wordArray[i >>> 2] |= str.charCodeAt(i) << ((i % 4) * 8);
          }
          
          wordArray[messageLength >>> 2] |= 0x80 << ((messageLength % 4) * 8);
          wordArray[numberOfWords - 2] = messageLength * 8;
          
          return wordArray;
        }

        function wordToHex(value) {
          let hex = "";
          for (let i = 0; i <= 3; i++) {
            const byte = (value >>> (i * 8)) & 255;
            hex += ("0" + byte.toString(16)).substr(-2);
          }
          return hex;
        }

        const wordArray = convertToWordArray(str);
        let h0 = 0x67452301;
        let h1 = 0xEFCDAB89;
        let h2 = 0x98BADCFE;
        let h3 = 0x10325476;

        for (let i = 0; i < wordArray.length; i += 16) {
          let a = h0;
          let b = h1;
          let c = h2;
          let d = h3;

          // Round 1
          a = ff(a, b, c, d, wordArray[i + 0], 7, 0xD76AA478);
          d = ff(d, a, b, c, wordArray[i + 1], 12, 0xE8C7B756);
          c = ff(c, d, a, b, wordArray[i + 2], 17, 0x242070DB);
          b = ff(b, c, d, a, wordArray[i + 3], 22, 0xC1BDCEEE);
          a = ff(a, b, c, d, wordArray[i + 4], 7, 0xF57C0FAF);
          d = ff(d, a, b, c, wordArray[i + 5], 12, 0x4787C62A);
          c = ff(c, d, a, b, wordArray[i + 6], 17, 0xA8304613);
          b = ff(b, c, d, a, wordArray[i + 7], 22, 0xFD469501);
          a = ff(a, b, c, d, wordArray[i + 8], 7, 0x698098D8);
          d = ff(d, a, b, c, wordArray[i + 9], 12, 0x8B44F7AF);
          c = ff(c, d, a, b, wordArray[i + 10], 17, 0xFFFF5BB1);
          b = ff(b, c, d, a, wordArray[i + 11], 22, 0x895CD7BE);
          a = ff(a, b, c, d, wordArray[i + 12], 7, 0x6B901122);
          d = ff(d, a, b, c, wordArray[i + 13], 12, 0xFD987193);
          c = ff(c, d, a, b, wordArray[i + 14], 17, 0xA679438E);
          b = ff(b, c, d, a, wordArray[i + 15], 22, 0x49B40821);

          // Round 2
          a = gg(a, b, c, d, wordArray[i + 1], 5, 0xF61E2562);
          d = gg(d, a, b, c, wordArray[i + 6], 9, 0xC040B340);
          c = gg(c, d, a, b, wordArray[i + 11], 14, 0x265E5A51);
          b = gg(b, c, d, a, wordArray[i + 0], 20, 0xE9B6C7AA);
          a = gg(a, b, c, d, wordArray[i + 5], 5, 0xD62F105D);
          d = gg(d, a, b, c, wordArray[i + 10], 9, 0x02441453);
          c = gg(c, d, a, b, wordArray[i + 15], 14, 0xD8A1E681);
          b = gg(b, c, d, a, wordArray[i + 4], 20, 0xE7D3FBC8);
          a = gg(a, b, c, d, wordArray[i + 9], 5, 0x21E1CDE6);
          d = gg(d, a, b, c, wordArray[i + 14], 9, 0xC33707D6);
          c = gg(c, d, a, b, wordArray[i + 3], 14, 0xF4D50D87);
          b = gg(b, c, d, a, wordArray[i + 8], 20, 0x455A14ED);
          a = gg(a, b, c, d, wordArray[i + 13], 5, 0xA9E3E905);
          d = gg(d, a, b, c, wordArray[i + 2], 9, 0xFCEFA3F8);
          c = gg(c, d, a, b, wordArray[i + 7], 14, 0x676F02D9);
          b = gg(b, c, d, a, wordArray[i + 12], 20, 0x8D2A4C8A);

          // Round 3
          a = hh(a, b, c, d, wordArray[i + 5], 4, 0xFFFA3942);
          d = hh(d, a, b, c, wordArray[i + 8], 11, 0x8771F681);
          c = hh(c, d, a, b, wordArray[i + 11], 16, 0x6D9D6122);
          b = hh(b, c, d, a, wordArray[i + 14], 23, 0xFDE5380C);
          a = hh(a, b, c, d, wordArray[i + 1], 4, 0xA4BEEA44);
          d = hh(d, a, b, c, wordArray[i + 4], 11, 0x4BDECFA9);
          c = hh(c, d, a, b, wordArray[i + 7], 16, 0xF6BB4B60);
          b = hh(b, c, d, a, wordArray[i + 10], 23, 0xBEBFBC70);
          a = hh(a, b, c, d, wordArray[i + 13], 4, 0x289B7EC6);
          d = hh(d, a, b, c, wordArray[i + 0], 11, 0xEAA127FA);
          c = hh(c, d, a, b, wordArray[i + 3], 16, 0xD4EF3085);
          b = hh(b, c, d, a, wordArray[i + 6], 23, 0x04881D05);
          a = hh(a, b, c, d, wordArray[i + 9], 4, 0xD9D4D039);
          d = hh(d, a, b, c, wordArray[i + 12], 11, 0xE6DB99E5);
          c = hh(c, d, a, b, wordArray[i + 15], 16, 0x1FA27CF8);
          b = hh(b, c, d, a, wordArray[i + 2], 23, 0xC4AC5665);

          // Round 4
          a = ii(a, b, c, d, wordArray[i + 0], 6, 0xF4292244);
          d = ii(d, a, b, c, wordArray[i + 7], 10, 0x432AFF97);
          c = ii(c, d, a, b, wordArray[i + 14], 15, 0xAB9423A7);
          b = ii(b, c, d, a, wordArray[i + 5], 21, 0xFC93A039);
          a = ii(a, b, c, d, wordArray[i + 12], 6, 0x655B59C3);
          d = ii(d, a, b, c, wordArray[i + 3], 10, 0x8F0CCC92);
          c = ii(c, d, a, b, wordArray[i + 10], 15, 0xFFEFF47D);
          b = ii(b, c, d, a, wordArray[i + 1], 21, 0x85845DD1);
          a = ii(a, b, c, d, wordArray[i + 8], 6, 0x6FA87E4F);
          d = ii(d, a, b, c, wordArray[i + 15], 10, 0xFE2CE6E0);
          c = ii(c, d, a, b, wordArray[i + 6], 15, 0xA3014314);
          b = ii(b, c, d, a, wordArray[i + 13], 21, 0x4E0811A1);
          a = ii(a, b, c, d, wordArray[i + 4], 6, 0xF7537E82);
          d = ii(d, a, b, c, wordArray[i + 11], 10, 0xBD3AF235);
          c = ii(c, d, a, b, wordArray[i + 2], 15, 0x2AD7D2BB);
          b = ii(b, c, d, a, wordArray[i + 9], 21, 0xEB86D391);

          h0 = addUnsigned(h0, a);
          h1 = addUnsigned(h1, b);
          h2 = addUnsigned(h2, c);
          h3 = addUnsigned(h3, d);
        }

        return wordToHex(h0) + wordToHex(h1) + wordToHex(h2) + wordToHex(h3);
      }
    };

    // =============================================================================
    // è…¾è®¯äº‘ç¿»è¯‘æ¨¡å—
    // =============================================================================
    
    const TencentTranslator = {
      endpoint: 'tmt.tencentcloudapi.com',
      service: 'tmt',
      version: '2018-03-21',
      region: 'ap-beijing',
      action: 'TextTranslate',

      // æ„å»ºè§„èŒƒè¯·æ±‚
      async buildCanonicalRequest(params) {
        const httpMethod = 'POST';
        const canonicalUri = '/';
        const canonicalQueryString = '';
        const canonicalHeaders = `content-type:application/json\nhost:${this.endpoint}\nx-tc-action:${this.action.toLowerCase()}\n`;
        const signedHeaders = 'content-type;host;x-tc-action';
        const payload = JSON.stringify(params);
        const hashedPayload = await CryptoUtils.sha256(payload);
        
        return `${httpMethod}\n${canonicalUri}\n${canonicalQueryString}\n${canonicalHeaders}\n${signedHeaders}\n${hashedPayload}`;
      },

      // æ„å»ºå¾…ç­¾åå­—ç¬¦ä¸²
      async buildStringToSign(canonicalRequest, timestamp) {
        const algorithm = 'TC3-HMAC-SHA256';
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        const credentialScope = `${date}/${this.service}/tc3_request`;
        const hashedCanonicalRequest = await CryptoUtils.sha256(canonicalRequest);
        
        return `${algorithm}\n${timestamp}\n${credentialScope}\n${hashedCanonicalRequest}`;
      },

      // è®¡ç®—ç­¾å
      async calculateSignature(stringToSign, secretKey, timestamp) {
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        
        const kDate = await CryptoUtils.hmacSha256('TC3' + secretKey, date);
        const kService = await CryptoUtils.hmacSha256(kDate, this.service);
        const kSigning = await CryptoUtils.hmacSha256(kService, 'tc3_request');
        const signature = await CryptoUtils.hmacSha256(kSigning, stringToSign);
        
        return signature;
      },

      // æ„å»ºAuthorizationå¤´
      async buildAuthorizationHeader(params, secretId, secretKey, timestamp) {
        const canonicalRequest = await this.buildCanonicalRequest(params);
        const stringToSign = await this.buildStringToSign(canonicalRequest, timestamp);
        const signature = await this.calculateSignature(stringToSign, secretKey, timestamp);
        
        const date = new Date(timestamp * 1000).toISOString().split('T')[0];
        const credentialScope = `${date}/${this.service}/tc3_request`;
        const signedHeaders = 'content-type;host;x-tc-action';
        
        return `TC3-HMAC-SHA256 Credential=${secretId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;
      },

      async translateTags(tagsArray) {
        const secretId = SettingsManager.getTencentSecretId();
        const secretKey = SettingsManager.getTencentSecretKey();
        
        if (!secretId || !secretKey) {
          throw new Error('è…¾è®¯äº‘å¯†é’¥é…ç½®ç¼ºå¤±ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®Secret IDå’ŒSecret Key');
        }

        try {
          // è¿‡æ»¤æ‰ç©ºæ ‡ç­¾å’Œæƒé‡æ ‡è®°
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const text = validTags.join('\n');
          const timestamp = Math.floor(Date.now() / 1000);
          
          const params = {
            SourceText: text,
            Source: 'en',
            Target: 'zh',
            ProjectId: 0
          };

          const authorizationHeader = await this.buildAuthorizationHeader(params, secretId, secretKey, timestamp);

          const headers = {
            'Authorization': authorizationHeader,
            'Content-Type': 'application/json',
            'Host': this.endpoint,
            'X-TC-Action': this.action,
            'X-TC-Timestamp': timestamp.toString(),
            'X-TC-Version': this.version,
            'X-TC-Region': this.region
          };

          const response = await fetch(`https://${this.endpoint}/`, {
            method: 'POST',
            headers: headers,
            body: JSON.stringify(params)
          });

          if (!response.ok) {
            throw new Error(`è…¾è®¯ç¿»è¯‘APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();
          
          if (result.Response.Error) {
            throw new Error(`è…¾è®¯ç¿»è¯‘é”™è¯¯: ${result.Response.Error.Message}`);
          }

          // åˆ†å‰²ç¿»è¯‘ç»“æœ
          const translations = result.Response.TargetText.split('\n');
          return translations;

        } catch (error) {
          console.error('è…¾è®¯ç¿»è¯‘å¤±è´¥:', error);
          throw error;
        }
      }
    };

    // =============================================================================
    // ç™¾åº¦ç¿»è¯‘æ¨¡å—
    // =============================================================================
    
    const BaiduTranslator = {
      endpoint: 'https://fanyi-api.baidu.com/api/trans/vip/translate',

      // ç”ŸæˆMD5ç­¾å
      generateSign(query, appid, salt, appkey) {
        const signStr = appid + query + salt + appkey;
        return CryptoUtils.md5(signStr);
      },

      async translateTags(tagsArray) {
        const appid = SettingsManager.getBaiduAppId();
        const appkey = SettingsManager.getBaiduAppKey();
        
        if (!appid || !appkey) {
          throw new Error('ç™¾åº¦ç¿»è¯‘å¯†é’¥é…ç½®ç¼ºå¤±ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½®App IDå’ŒApp Key');
        }

        try {
          // è¿‡æ»¤æ‰ç©ºæ ‡ç­¾å’Œæƒé‡æ ‡è®°
          const validTags = tagsArray.filter(tag => 
            tag && 
            tag.trim() && 
            !tag.match(/^[\d.]+::$/) && 
            !tag.match(/^::$/) &&
            !tag.match(/^[{}\[\]]+$/)
          );

          if (validTags.length === 0) {
            return [];
          }

          const query = validTags.join('\n');
          const salt = Date.now().toString();
          const sign = this.generateSign(query, appid, salt, appkey);

          const params = new URLSearchParams({
            q: query,
            from: 'en',
            to: 'zh',
            appid: appid,
            salt: salt,
            sign: sign
          });

          const response = await fetch(this.endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: params
          });

          if (!response.ok) {
            throw new Error(`ç™¾åº¦ç¿»è¯‘APIè¯·æ±‚å¤±è´¥: ${response.status} ${response.statusText}`);
          }

          const result = await response.json();

          if (result.error_code) {
            throw new Error(`ç™¾åº¦ç¿»è¯‘é”™è¯¯(${result.error_code}): ${result.error_msg || 'æœªçŸ¥é”™è¯¯'}`);
          }

          // å¤„ç†ç™¾åº¦ç¿»è¯‘çš„è¿”å›æ ¼å¼
          if (!result.trans_result || !Array.isArray(result.trans_result)) {
            throw new Error('ç™¾åº¦ç¿»è¯‘è¿”å›æ ¼å¼é”™è¯¯');
          }

          // ç™¾åº¦ç¿»è¯‘è¿”å›æ ¼å¼: {trans_result: [{src: '', dst: ''}]}
          // å¦‚æœæ˜¯å¤šä¸ªå¥å­ï¼Œä¼šè¿”å›å¤šä¸ªå¯¹è±¡
          if (result.trans_result.length === 1) {
            // å•ä¸ªç¿»è¯‘ç»“æœï¼ŒæŒ‰æ¢è¡Œç¬¦åˆ†å‰²
            return result.trans_result[0].dst.split('\n');
          } else {
            // å¤šä¸ªç¿»è¯‘ç»“æœ
            return result.trans_result.map(item => item.dst);
          }

        } catch (error) {
          console.error('ç™¾åº¦ç¿»è¯‘å¤±è´¥:', error);
          throw error;
        }
      }
    };

    // =============================================================================
    // ç»Ÿä¸€ç¿»è¯‘ç®¡ç†å™¨
    // =============================================================================
    
    const TranslationManager = {
      providers: {},
      localCache: new Map(),
      cacheLoaded: false,
      cacheLoading: false,
      cacheUrl: 'https://ghfast.top/https://raw.githubusercontent.com/Natsukage/novelai-prompt-reader/main/translations.json',

      init() {
        this.providers = {
          [TranslationProviders.GEMINI]: GeminiTranslator,
          [TranslationProviders.TENCENT]: TencentTranslator,
          [TranslationProviders.BAIDU]: BaiduTranslator
        };
      },

      async loadLocalCache() {
        if (this.cacheLoaded || this.cacheLoading) {
          return;
        }

        this.cacheLoading = true;
        try {
          const response = await fetch(this.cacheUrl);
          if (!response.ok) {
            throw new Error(`åŠ è½½ç¼“å­˜å¤±è´¥: ${response.status}`);
          }
          
          const translations = await response.json();
          this.localCache = new Map(Object.entries(translations));
          this.cacheLoaded = true;
          console.log(`æœ¬åœ°ç¿»è¯‘ç¼“å­˜åŠ è½½æˆåŠŸï¼ŒåŒ…å« ${this.localCache.size} ä¸ªç¿»è¯‘æ¡ç›®`);
        } catch (error) {
          console.warn('æœ¬åœ°ç¿»è¯‘ç¼“å­˜åŠ è½½å¤±è´¥:', error);
        } finally {
          this.cacheLoading = false;
        }
      },

      getCachedTranslation(text) {
        if (!this.cacheLoaded) {
          return null;
        }
        return this.localCache.get(text.toLowerCase().trim());
      },

      async translateWithCache(tags) {
        if (!this.cacheLoaded && !this.cacheLoading) {
          this.loadLocalCache();
        }

        if (this.cacheLoaded) {
          const results = [];
          const uncachedTags = [];
          
          for (const tag of tags) {
            const cached = this.getCachedTranslation(tag);
            if (cached) {
              results.push(cached);
            } else {
              uncachedTags.push(tag);
              results.push(null);
            }
          }
          
          if (uncachedTags.length === 0) {
            return results;
          }
          
          try {
            const apiResults = await this.robustTranslateTags(uncachedTags);
            let apiIndex = 0;
            
            for (let i = 0; i < results.length; i++) {
              if (results[i] === null) {
                results[i] = apiResults[apiIndex];
                apiIndex++;
              }
            }
            
            return results;
          } catch (error) {
            console.warn('APIç¿»è¯‘å¤±è´¥ï¼Œè¿”å›éƒ¨åˆ†ç¼“å­˜ç»“æœ:', error);
            return results.map((result, index) => result || tags[index]);
          }
        }
        
        return await this.robustTranslateTags(tags);
      },

      async translateTags(tags, provider = null) {
        if (!this.providers[TranslationProviders.GEMINI]) {
          this.init();
        }

        const currentProvider = provider || SettingsManager.getTranslationProvider();
        
        if (!this.providers[currentProvider]) {
          throw new Error(`ä¸æ”¯æŒçš„ç¿»è¯‘æœåŠ¡æä¾›å•†: ${currentProvider}`);
        }

        return await this.providers[currentProvider].translateTags(tags);
      },

      async translate(tags) {
        try {
          return await this.translateWithCache(tags);
        } catch (error) {
          console.warn('ç¿»è¯‘å¤±è´¥:', error);
          return tags;
        }
      },

      // å¥å£®ç¿»è¯‘ï¼ˆå¸¦é™çº§æœºåˆ¶ï¼‰
      async robustTranslateTags(tags) {
        const primaryProvider = SettingsManager.getTranslationProvider();
        const fallbackProviders = [TranslationProviders.GEMINI, TranslationProviders.TENCENT, TranslationProviders.BAIDU]
          .filter(p => p !== primaryProvider);

        // å°è¯•ä¸»è¦æä¾›å•†
        try {
          if (SettingsManager.hasValidCurrentProviderConfig()) {
            return await this.translateTags(tags, primaryProvider);
          } else {
            throw new Error(`${primaryProvider} é…ç½®æ— æ•ˆ`);
          }
        } catch (error) {
          console.warn(`${primaryProvider} ç¿»è¯‘å¤±è´¥ï¼Œå°è¯•é™çº§:`, error);
          
          // å°è¯•é™çº§åˆ°å…¶ä»–æä¾›å•†
          for (const provider of fallbackProviders) {
            try {
              // æ£€æŸ¥é…ç½®æœ‰æ•ˆæ€§
              let hasValidConfig = false;
              switch (provider) {
                case TranslationProviders.GEMINI:
                  hasValidConfig = SettingsManager.hasValidGeminiConfig();
                  break;
                case TranslationProviders.TENCENT:
                  hasValidConfig = SettingsManager.hasValidTencentConfig();
                  break;
                case TranslationProviders.BAIDU:
                  hasValidConfig = SettingsManager.hasValidBaiduConfig();
                  break;
              }

              if (!hasValidConfig) {
                console.warn(`${provider} é…ç½®æ— æ•ˆï¼Œè·³è¿‡`);
                continue;
              }

              const result = await this.translateTags(tags, provider);
              showToast(`å·²é™çº§ä½¿ç”¨ ${provider} ç¿»è¯‘æœåŠ¡`);
              return result;
            } catch (fallbackError) {
              console.warn(`${provider} é™çº§ç¿»è¯‘ä¹Ÿå¤±è´¥:`, fallbackError);
            }
          }
          
          throw new Error('æ‰€æœ‰ç¿»è¯‘æœåŠ¡éƒ½ä¸å¯ç”¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒAPIé…ç½®');
        }
      }
    };

    // =============================================================================
    // DOMå·¥å…·å‡½æ•°
    const DOMUtils = {
      getElementById(id) {
        const element = document.getElementById(id);
        if (!element) {
          console.warn(`Element with id '${id}' not found`);
        }
        return element;
      },

      toggleElementDisplay(elementId, show) {
        const element = this.getElementById(elementId);
        if (element) {
          element.style.display = show ? "block" : "none";
        }
      },

      setElementContent(elementId, content) {
        const element = this.getElementById(elementId);
        if (element) {
          element.innerHTML = content;
        }
      }
    };

    // é”™è¯¯å¤„ç†å·¥å…·
    const ErrorHandler = {
      logError(message, error) {
        console.error(message, error);
      },

      handleProcessingError(error, context = "æœªçŸ¥æ“ä½œ") {
        this.logError(`${context}æ—¶å‡ºé”™:`, error);
        showToast(`${context}æ—¶å‡ºé”™ï¼Œè¯·é‡è¯•`);
      }
    };

    function showToast(message) {
      const toast = DOMUtils.getElementById("toast");
      if (toast) {
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => {
          toast.classList.remove("show");
        }, 3000);
      }
    }

    function copyToClipboard(text) {
      navigator.clipboard
        .writeText(text)
        .then(() => {
          showToast("å¤åˆ¶æˆåŠŸï¼");
        })
        .catch(() => {
          showToast("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶");
        });
    }

    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + " B";
      else if (bytes < 1048576) return (bytes / 1024).toFixed(2) + " KB";
      else return (bytes / 1048576).toFixed(2) + " MB";
    }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    // =============================================================================
    // æ–‡ä»¶å¤„ç†æ¨¡å—
    // =============================================================================
    
    // å¤„ç†æ–‡ä»¶åæ˜¾ç¤º - ä¸­é—´çœç•¥ï¼Œä¿ç•™æ‰©å±•å
    function truncateFilename(filename, maxWidth) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      context.font = '0.95rem -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';

      // å¦‚æœæ–‡ä»¶åå®½åº¦å°äºæœ€å¤§å®½åº¦ï¼Œç›´æ¥è¿”å›
      if (context.measureText(filename).width <= maxWidth) {
        return filename;
      }

      // æå–æ–‡ä»¶åå’Œæ‰©å±•å
      const lastDotIndex = filename.lastIndexOf(".");
      const extension = lastDotIndex !== -1 ? filename.substring(lastDotIndex) : "";
      const nameWithoutExt = lastDotIndex !== -1 ? filename.substring(0, lastDotIndex) : filename;

      // è®¡ç®—çœç•¥å·å’Œæ‰©å±•åçš„å®½åº¦
      const ellipsisWidth = context.measureText("...").width;
      const extensionWidth = context.measureText(extension).width;

      // é¢„ç•™è‡³å°‘3ä¸ªå­—ç¬¦çš„ç©ºé—´åœ¨çœç•¥å·å‰ï¼Œé˜²æ­¢çœç•¥å·ç´§è´´æ‰©å±•å
      const minEndChars = Math.min(3, Math.floor(nameWithoutExt.length / 2));
      const endPart = nameWithoutExt.substring(nameWithoutExt.length - minEndChars);
      const endPartWidth = context.measureText(endPart).width;

      const totalEndWidth = ellipsisWidth + endPartWidth + extensionWidth;
      const availableWidth = maxWidth - totalEndWidth;

      // äºŒåˆ†æŸ¥æ‰¾åˆé€‚çš„æˆªæ–­é•¿åº¦
      let start = 0;
      let end = nameWithoutExt.length - minEndChars;
      let bestLength = 0;

      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const truncated = nameWithoutExt.substring(0, mid);
        const width = context.measureText(truncated).width;

        if (width <= availableWidth) {
          bestLength = mid;
          start = mid + 1;
        } else {
          end = mid - 1;
        }
      }

      if (bestLength === 0) {
        return "..." + endPart + extension;
      }

      return nameWithoutExt.substring(0, bestLength) + "..." + endPart + extension;
    }

    // =============================================================================
    // é…ç½®å’Œå¸¸é‡æ¨¡å—
    // =============================================================================
    
    const CONFIG = {
      // ç•Œé¢é…ç½®
      UI: {
        FILENAME_MAX_WIDTH: 250,
        TOAST_DURATION: 3000,
        ANIMATION_DELAY_STEP: 0.1
      },

      // NovelAIé…ç½®
      NOVELAI: {
        DEFAULT_POSITIVE_TAGS: ["very aesthetic", "masterpiece", "no text"],
        DEFAULT_NEGATIVE_TAGS: [
          "nsfw","lowres","artistic error","film grain","scan artifacts","worst quality","bad quality",
          "jpeg artifacts","very displeasing","chromatic aberration","dithering","halftone",
          "screentone","multiple views","logo","too many watermarks","negative space","blank page"
        ],
        WEIGHT_MULTIPLIER: 1.1,
        STEGANOGRAPHY_MAGIC: "stealth_pngcomp"
      },

      // æ”¯æŒçš„æ–‡ä»¶ç±»å‹
      SUPPORTED_FILE_TYPES: ["image/png", "image/jpeg", "image/jpg"],
      
      // å…ƒæ•°æ®ç±»å‹
      METADATA_TYPES: {
        SD_WEBUI: "SD-WEBUI",
        NOVELAI: "NOVELAI", 
        UNKNOWN: "UNKNOWN"
      }
    };

    // =============================================================================
    // Promptå¤„ç†æ¨¡å—
    // =============================================================================

    // Promptæ ¼å¼åŒ–å‡½æ•°
    function formatPrompt(prompt) {
      if (!prompt || typeof prompt !== "string") return prompt;

      // 1. å»é™¤è½¬ä¹‰å­—ç¬¦
      let formatted = prompt.replace(/\\([()])/g, "$1");
      // 2. å»é™¤å¤šä½™çš„è¿ç»­é€—å·
      formatted = formatted.replace(/,{2,}/g, ",");
      // 3. æ ‡å‡†åŒ–é€—å·åçš„ç©ºæ ¼ï¼šç¡®ä¿é€—å·åæœ‰ä¸”ä»…æœ‰ä¸€ä¸ªç©ºæ ¼
      formatted = formatted.replace(/,\s*/g, ", ");
      // 4. å»é™¤å¼€å¤´å’Œç»“å°¾çš„é€—å·å’Œç©ºæ ¼
      formatted = formatted.replace(/^[\s,]+|[\s,]+$/g, "");

      return formatted;
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
    function isDefaultTag(tagContent, isNegativePrompt = false) {
      const content = tagContent.toLowerCase().trim();
      const defaultTags = isNegativePrompt ? CONFIG.NOVELAI.DEFAULT_NEGATIVE_TAGS : CONFIG.NOVELAI.DEFAULT_POSITIVE_TAGS;
      return defaultTags.some((defaultTag) => content === defaultTag.toLowerCase() || content.includes(defaultTag.toLowerCase()));
    }

    // NovelAIæƒé‡è§£æå™¨
    function parsePromptWeights(prompt) {
      const tokens = [];
      let i = 0;
      let currentWeight = 1.0;
      const weightStack = [1.0]; // ç”¨äºå¤„ç†åµŒå¥—æƒé‡

      while (i < prompt.length) {
        const char = prompt[i];

        // å¤„ç†æ•°å­—æƒé‡è¯­æ³•ï¼šæ•°å­—::
        if (char.match(/[-\d]/) && prompt.substring(i).match(/^[-\d.]+::/)) {
          const match = prompt.substring(i).match(/^([-\d.]+)::/);
          if (match) {
            const weight = parseFloat(match[1]);
            tokens.push({
              type: "weight-marker",
              content: match[0],
              weight: weight,
            });
            currentWeight = weight;
            weightStack.push(weight); // æ¨å…¥æ–°æƒé‡
            i += match[0].length;
            continue;
          }
        }

        // å¤„ç†æƒé‡ç»“æŸæ ‡è®°ï¼š::
        if (prompt.substring(i, i + 2) === "::") {
          tokens.push({
            type: "weight-marker",
            content: "::",
            weight: 1.0,
          });
          // æ¢å¤åˆ°æƒé‡æ ˆçš„ä¸Šä¸€å±‚
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i += 2;
          continue;
        }

        // å¤„ç†æ—§å¼æƒé‡ï¼š{ å’Œ [
        if (char === "{") {
          const newWeight = currentWeight * CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "{",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "[") {
          const newWeight = currentWeight / CONFIG.NOVELAI.WEIGHT_MULTIPLIER;
          tokens.push({
            type: "weight-marker",
            content: "[",
            weight: newWeight,
          });
          currentWeight = newWeight;
          weightStack.push(newWeight);
          i++;
          continue;
        }

        if (char === "}" || char === "]") {
          tokens.push({
            type: "weight-marker",
            content: char,
            weight: 1.0,
          });
          if (weightStack.length > 1) {
            weightStack.pop();
            currentWeight = weightStack[weightStack.length - 1];
          } else {
            currentWeight = 1.0;
          }
          i++;
          continue;
        }

        // å¤„ç†é€—å·
        if (char === ",") {
          tokens.push({
            type: "comma",
            content: char,
            weight: 1.0,
          });
          i++;
          // è·³è¿‡é€—å·åçš„ç©ºæ ¼
          while (i < prompt.length && prompt[i] === " ") {
            i++;
          }
          continue;
        }

        // è·³è¿‡å…¶ä»–ç©ºæ ¼
        if (char === " ") {
          i++;
          continue;
        }

        // å¤„ç†æ™®é€šæ–‡æœ¬
        let textContent = "";
        while (i < prompt.length) {
          const currentChar = prompt[i];
          const nextTwoChars = prompt.substring(i, i + 2);

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡æ ‡è®°çš„å¼€å§‹
          if (prompt.substring(i).match(/^[-\d.]+::/)) {
            break;
          }

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æƒé‡ç»“æŸæ ‡è®°
          if (nextTwoChars === "::") {
            break;
          }

          // æ£€æŸ¥æ˜¯å¦é‡åˆ°æ‹¬å·æˆ–é€—å·
          if ("{[}],".includes(currentChar)) {
            break;
          }

          textContent += currentChar;
          i++;
        }

        if (textContent.trim()) {
          tokens.push({
            type: "text",
            content: textContent.trim(),
            weight: currentWeight,
          });
        }
      }

      return tokens;
    }

    // æå–promptä¸­çš„çº¯æ–‡æœ¬tagsï¼ˆç”¨äºç¿»è¯‘ï¼‰
    function extractTextTags(prompt) {
      const formatted = formatPrompt(prompt);
      const tokens = parsePromptWeights(formatted);
      
      return tokens
        .filter(token => token.type === "text" && token.content && token.content.trim())
        .map(token => token.content.trim());
    }

    // æ¸²æŸ“æƒé‡é«˜äº®çš„Prompt
    function renderHighlightedPrompt(prompt, isNegativePrompt = false) {
      const formatted = formatPrompt(prompt);
      const tokens = parsePromptWeights(formatted);

      let html = "";
      let textTagIndex = 0; // ç”¨äºè¿½è¸ªæ–‡æœ¬tagçš„ç´¢å¼•

      tokens.forEach((token, index) => {
        if (token.type === "weight-marker") {
          html += `<span class="prompt-weight-marker">${escapeHtml(token.content)}</span>`;
        } else if (token.type === "comma") {
          // åœ¨é€—å·åæ·»åŠ çœŸå®ç©ºæ ¼ï¼Œç»™æµè§ˆå™¨æ­£ç¡®çš„æ¢è¡Œä½ç½®
          html += `<span class="prompt-comma">${escapeHtml(token.content)}</span> `;
        } else if (token.type === "text" && token.content) {
          let className = "prompt-tag weight-normal";

          // æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤tag
          const isDefault = isDefaultTag(token.content, isNegativePrompt);

          if (isDefault) {
            className = "prompt-tag default-tag";
          } else if (Math.abs(token.weight) > 1.0) {
            className = "prompt-tag weight-high";
          } else if (Math.abs(token.weight) < 1.0 && token.weight !== 0) {
            className = "prompt-tag weight-low";
          }

          // æ·»åŠ data-tag-indexç”¨äºæ‚¬åœæ•ˆæœ
          html += `<span class="${className}" data-tag-index="${textTagIndex}">${escapeHtml(token.content)}</span>`;
          textTagIndex++;

          // åœ¨æ–‡æœ¬tokenåæ·»åŠ ç©ºæ ¼ï¼Œé™¤éä¸‹ä¸€ä¸ªtokenæ˜¯é€—å·æˆ–æƒé‡æ ‡è®°
          if (index < tokens.length - 1) {
            const nextToken = tokens[index + 1];
            if (nextToken.type !== "comma" && nextToken.type !== "weight-marker") {
              html += " ";
            }
          }
        }
      });

      return html;
    }

    // æ¸²æŸ“ç¿»è¯‘ç»“æœ
    function renderTranslatedTags(translations) {
      let html = "";
      
      translations.forEach((translation, index) => {
        if (index > 0) {
          html += `<span class="translation-comma">, </span>`;
        }
        html += `<span class="translation-tag" data-tag-index="${index}">${escapeHtml(translation)}</span>`;
      });
      
      return html;
    }

    // =============================================================================
    // å›¾ç‰‡å…ƒæ•°æ®è§£ææ¨¡å—
    // =============================================================================
    
    // PNG Chunk è§£æ
    function extractPngChunks(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      const chunks = [];
      let offset = 8; // Skip PNG signature

      while (offset < arrayBuffer.byteLength - 12) {
        const length = dataView.getUint32(offset, false);
        const type = String.fromCharCode(
          dataView.getUint8(offset + 4),
          dataView.getUint8(offset + 5),
          dataView.getUint8(offset + 6),
          dataView.getUint8(offset + 7)
        );

        const data = new Uint8Array(arrayBuffer, offset + 8, length);
        chunks.push({ type, data });

        offset += length + 12; // length + type + data + crc
      }

      return chunks;
    }

    function decodePngTextChunk(data, chunkType) {
      if (chunkType === "tEXt") {
        const nullIndex = data.indexOf(0);
        const keyword = new TextDecoder().decode(data.slice(0, nullIndex));
        const text = new TextDecoder().decode(data.slice(nullIndex + 1));
        return { keyword, text };
      } else if (chunkType === "iTXt") {
        // iTXtæ ¼å¼æ›´å¤æ‚ï¼ŒåŒ…å«å‹ç¼©æ ‡å¿—å’Œè¯­è¨€æ ‡ç­¾
        const filteredData = data.filter((x) => x != 0x0);
        const header = new TextDecoder().decode(filteredData.slice(0, 11));
        if (header === "Description") {
          const txt = new TextDecoder().decode(filteredData.slice(11));
          return { keyword: "Description", text: txt };
        } else {
          const txt = new TextDecoder().decode(filteredData);
          return { keyword: "Comment", text: txt };
        }
      }
      return { keyword: "Unknown", text: "" };
    }

    // æå–å…ƒæ•°æ®
    async function extractMetadata(file) {
      if (file.type === "image/png") {
        const buf = await file.arrayBuffer();
        let chunks = [];
        try {
          chunks = extractPngChunks(buf);
        } catch (err) {
          console.error("PNG chunk è§£æå¤±è´¥:", err);
          return [];
        }

        const textChunks = chunks
          .filter(function (chunk) {
            return chunk.type === "tEXt" || chunk.type === "iTXt";
          })
          .map(function (chunk) {
            return decodePngTextChunk(chunk.data, chunk.type);
          })
          .filter(chunk => chunk.keyword !== "Unknown");

        console.log("æå–çš„æ–‡æœ¬å—:", textChunks);
        return textChunks;
      }
      return [];
    }

    // =============================================================================
    // éšå†™æœ¯è§£ææ¨¡å—
    // =============================================================================
    
    // éšå†™æœ¯EXIFæå–
    async function getStealthExif(src) {
      let time = performance.now();

      let canvas = document.createElement('canvas');
      let ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: true });
      let img = new Image();
      img.src = src;

      await img.decode();

      canvas.width = img.width;
      canvas.height = img.height;
      ctx.drawImage(img, 0, 0);

      let imageData = ctx.getImageData(0, 0, img.width, img.height);
      let lowestData = [];

      for (let x = 0; x < img.width; x++) {
        for (let y = 0; y < img.height; y++) {
          let index = (y * img.width + x) * 4;
          let a = imageData.data[index + 3];
          lowestData.push(a & 1);
        }
      }

      console.log("éšå†™æœ¯æå–è€—æ—¶: ", performance.now() - time, "ms");

      // æ•°æ®è¯»å–å™¨ç±»
      class DataReader {
        constructor(data) {
          this.data = data;
          this.index = 0;
        }

        readBit() {
          return this.data[this.index++];
        }

        readNBits(n) {
          let bits = [];
          for (let i = 0; i < n; i++) {
            bits.push(this.readBit());
          }
          return bits;
        }

        readByte() {
          let byte = 0;
          for (let i = 0; i < 8; i++) {
            byte |= this.readBit() << (7 - i);
          }
          return byte;
        }

        readNBytes(n) {
          let bytes = [];
          for (let i = 0; i < n; i++) {
            bytes.push(this.readByte());
          }
          return bytes;
        }

        readInt32() {
          let bytes = this.readNBytes(4);
          return new DataView(new Uint8Array(bytes).buffer).getInt32(0, false);
        }
      }

      const magic = CONFIG.NOVELAI.STEGANOGRAPHY_MAGIC;
      const reader = new DataReader(lowestData);
      const readMagic = reader.readNBytes(magic.length);
      const magicString = String.fromCharCode.apply(null, readMagic);

      if (magic === magicString) {
        console.log("æ‰¾åˆ°éšå†™æ•°æ®ï¼");
        const dataLength = reader.readInt32();
        console.log("æ•°æ®é•¿åº¦:", dataLength);
        const gzipData = reader.readNBytes(dataLength / 8);

        const data = pako.ungzip(new Uint8Array(gzipData));
        const jsonString = new TextDecoder().decode(new Uint8Array(data));
        const json = JSON.parse(jsonString);
        return json;
      } else {
        console.log("æœªæ‰¾åˆ°éšå†™æ•°æ®æ ‡è®°");
      }

      return null;
    }

    // =============================================================================
    // æ•°æ®è§£ææ¨¡å—
    // =============================================================================
    
    // è§£æNovelAIçš„JSONæ•°æ®
    function parseNovelAIData(details) {
      const result = {
        basic: [],
        prompts: [],
        technical: [],
      };

      // ä¸»Prompt
      if (details.prompt) {
        result.prompts.push({
          label: "ä¸»Prompt",
          value: details.prompt,
          copyable: true,
        });
      }

      // è´Ÿé¢Prompt
      if (details.uc) {
        result.prompts.push({
          label: "è´Ÿé¢Prompt",
          value: details.uc,
          copyable: true,
        });
      }

      // V4 è§’è‰²Prompts - æŒ‰ç…§è§’è‰²é¡ºåºæ˜¾ç¤º
      const charPrompts = [];
      const charNegativePrompts = [];

      if (details.v4_prompt && details.v4_prompt.caption && details.v4_prompt.caption.char_captions) {
        details.v4_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charPrompts[index] = {
              label: `è§’è‰²${index + 1} Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      if (details.v4_negative_prompt && details.v4_negative_prompt.caption && details.v4_negative_prompt.caption.char_captions) {
        details.v4_negative_prompt.caption.char_captions.forEach((char, index) => {
          if (char.char_caption && char.char_caption.trim()) {
            charNegativePrompts[index] = {
              label: `è§’è‰²${index + 1} è´Ÿé¢Prompt`,
              value: char.char_caption,
              copyable: true,
            };
          }
        });
      }

      // æŒ‰ç…§è§’è‰²é¡ºåºæ·»åŠ Promptå’Œè´Ÿé¢Prompt
      const maxCharIndex = Math.max(charPrompts.length, charNegativePrompts.length);
      for (let i = 0; i < maxCharIndex; i++) {
        if (charPrompts[i]) {
          result.prompts.push(charPrompts[i]);
        }
        if (charNegativePrompts[i]) {
          result.prompts.push(charNegativePrompts[i]);
        }
      }

      // æŠ€æœ¯å‚æ•°
      result.technical.push({
        label: "é‡‡æ ·å™¨",
        value: details.sampler || "Unknown",
      });
      result.technical.push({
        label: "æ­¥æ•°",
        value: details.steps || "Unknown",
      });
      result.technical.push({
        label: "å°ºå¯¸",
        value: `${details.width || "?"} Ã— ${details.height || "?"}`,
      });
      result.technical.push({
        label: "CFG Scale",
        value: details.scale || "Unknown",
      });
      result.technical.push({
        label: "ç§å­",
        value: details.seed || "Unknown",
      });
      if (details.noise_schedule) {
        result.technical.push({
          label: "å™ªå£°è®¡åˆ’",
          value: details.noise_schedule,
        });
      }
      if (details.cfg_rescale !== undefined) {
        result.technical.push({
          label: "CFG Rescale",
          value: details.cfg_rescale,
        });
      }
      if (details.strength !== undefined) {
        result.technical.push({
          label: "Strength",
          value: details.strength,
        });
      }
      if (details.noise !== undefined) {
        result.technical.push({
          label: "Noise",
          value: details.noise,
        });
      }
      if (details.generation_time !== undefined) {
        result.technical.push({
          label: "ç”Ÿæˆæ—¶é—´",
          value: `${details.generation_time.toFixed(4)}s`,
        });
      }
      if (details.request_type) {
        result.technical.push({
          label: "è¯·æ±‚ç±»å‹",
          value: details.request_type,
          wide: true,
        });
      }

      return result;
    }

    // å¤„ç†WebUIæ ¼å¼
    function parseWebUIData(text) {
      const result = {
        prompts: [],
        technical: [],
      };

      const parts = text.split("Steps: ");
      if (parts.length >= 2) {
        const promptPart = parts[0];
        const paramsPart = "Steps: " + parts[1];

        const promptSplit = promptPart.split("Negative prompt: ");

        result.prompts.push({
          label: "æ­£é¢æç¤ºè¯",
          value: promptSplit[0].trim(),
          copyable: true,
        });

        if (promptSplit.length > 1) {
          result.prompts.push({
            label: "è´Ÿé¢æç¤ºè¯",
            value: promptSplit[1].trim(),
            copyable: true,
          });
        }

        // è§£æå‚æ•°
        const params = paramsPart.match(/(\w+[\s\w]*): ([^,]+)/g);
        if (params) {
          params.forEach((param) => {
            const [key, value] = param.split(": ");
            result.technical.push({
              label: key,
              value: value,
            });
          });
        }
      }

      return result;
    }

    // å¤„ç†WebUIæ ¼å¼æ•°æ®
    function handleWebUiTag(data) {
      let [prompts, otherParas] = data.text.split("Steps: ");
      let promptSplit = prompts.split("Negative prompt: ");
      let negativePrompt = promptSplit.length > 1 ? promptSplit[1] : "æ— ";
      return [
        {
          label: "æç¤ºè¯",
          value: promptSplit[0],
          copyable: true,
        },
        {
          label: "è´Ÿé¢æç¤ºè¯",
          value: negativePrompt,
          copyable: true,
        },
        {
          label: "å…¶ä»–å‚æ•°",
          value: "Steps: " + otherParas,
          copyable: true,
        },
      ];
    }

    // =============================================================================
    // UIæ¸²æŸ“æ¨¡å—
    // =============================================================================
    
    // æ¸²æŸ“æŠ€æœ¯å‚æ•°åˆ°å·¦ä¾§
    function renderTechnicalParams(technicalData) {
      const technicalPanel = document.getElementById("technicalPanel");
      const technicalParams = document.getElementById("technicalParams");

      if (technicalData && technicalData.length > 0) {
        technicalParams.innerHTML = "";

        technicalData.forEach((item) => {
          const paramEl = document.createElement("div");
          paramEl.className = "tech-param-item";
          if (item.wide) {
            paramEl.classList.add("wide");
          }

          const labelEl = document.createElement("div");
          labelEl.className = "tech-param-label";
          labelEl.textContent = item.label;

          const valueEl = document.createElement("div");
          valueEl.className = "tech-param-value";
          valueEl.textContent = item.value.toString();

          // æ·»åŠ ç‚¹å‡»å¤åˆ¶åŠŸèƒ½
          paramEl.addEventListener("click", () => {
            copyToClipboard(item.value.toString());
          });

          paramEl.appendChild(labelEl);
          paramEl.appendChild(valueEl);
          technicalParams.appendChild(paramEl);
        });

        technicalPanel.style.display = "block";
      } else {
        technicalPanel.style.display = "none";
      }
    }

    // æ¸²æŸ“ä¿¡æ¯åˆ°å³ä¾§ï¼ˆä¸åŒ…æ‹¬æŠ€æœ¯å‚æ•°ï¼‰
    function renderInfo(data) {
      const container = document.getElementById("infoContainer");
      container.innerHTML = "";

      // Prompts - è¿‡æ»¤æ‰ä¸éœ€è¦çš„å­—æ®µ
      if (data.prompts && data.prompts.length > 0) {
        const filteredPrompts = data.prompts.filter((item) => {
          if (!item || (!item.label && !item.key)) {
            return false; // è¿‡æ»¤æ‰æ— æ•ˆçš„é¡¹ç›®
          }
          const label = (item.label || item.key).toLowerCase();
          return !label.includes("title") && !label.includes("description") && !label.includes("åŸºç¡€caption") && !label.includes("è´Ÿé¢åŸºç¡€caption") && !label.includes("generation_time");
        });

        if (filteredPrompts.length > 0) {
          const section = createSection("Prompts", "âœ¨", filteredPrompts);
          container.appendChild(section);
          
          // å¦‚æœå¯ç”¨äº†ç¿»è¯‘ï¼Œå¼€å§‹ç¿»è¯‘prompt
          if (SettingsManager.isTranslationEnabled() && SettingsManager.hasValidCurrentProviderConfig()) {
            translatePrompts(filteredPrompts);
          }
        }
      }

      // EXIFä¿¡æ¯
      if (data.exif && data.exif.length > 0) {
        const section = createSection("EXIFä¿¡æ¯", "ğŸ“·", data.exif);
        container.appendChild(section);
      }
    }

    // å¼‚æ­¥ç¿»è¯‘promptå‡½æ•°
    async function translatePrompts(promptsArray) {
      // åªç¿»è¯‘promptç±»å‹çš„å†…å®¹
      const promptsToTranslate = promptsArray.filter(item => {
        const label = (item.label || item.key || '').toLowerCase();
        return label.includes('prompt') || label.includes('caption') || label === 'description';
      });

      if (promptsToTranslate.length === 0) return;

      // æ˜¾ç¤ºç¿»è¯‘åŠ è½½çŠ¶æ€
      promptsToTranslate.forEach((item, index) => {
        const promptContainer = document.querySelector(`[data-prompt-index="${index}"]`);
        if (promptContainer) {
          const translationContainer = promptContainer.querySelector('.prompt-translation');
          if (translationContainer) {
            translationContainer.style.display = 'block';
            translationContainer.innerHTML = '<div class="translation-loading"><span class="spinner"></span>æ­£åœ¨ç¿»è¯‘...</div>';
          }
        }
      });

      // ä¸ºæ¯ä¸ªpromptå•ç‹¬ç¿»è¯‘
      for (let index = 0; index < promptsToTranslate.length; index++) {
        const item = promptsToTranslate[index];
        const promptContainer = document.querySelector(`[data-prompt-index="${index}"]`);
        
        if (!promptContainer) continue;
        
        const translationContainer = promptContainer.querySelector('.prompt-translation');
        if (!translationContainer) continue;

        try {
          // æå–tags
          const tags = extractTextTags(item.value);
          
          if (tags.length === 0) {
            translationContainer.innerHTML = '<div class="translation-error">æ— å¯ç¿»è¯‘çš„æ ‡ç­¾</div>';
            continue;
          }

          // ç¿»è¯‘tags
          const translations = await TranslationManager.translate(tags);
          
          if (translations.length > 0) {
            // æ¸²æŸ“ç¿»è¯‘ç»“æœ
            const translatedHtml = renderTranslatedTags(translations);
            translationContainer.innerHTML = `${translatedHtml}`;
            
            // æ·»åŠ æ‚¬åœæ•ˆæœ
            addHoverEffects(promptContainer);
          } else {
            translationContainer.innerHTML = '<div class="translation-error">ç¿»è¯‘å¤±è´¥</div>';
          }
          
        } catch (error) {
          console.error(`ç¿»è¯‘ç¬¬${index + 1}ä¸ªpromptå¤±è´¥:`, error);
          translationContainer.innerHTML = '<div class="translation-error">ç¿»è¯‘å¤±è´¥</div>';
        }
      }
    }

    // æ·»åŠ æ‚¬åœæ•ˆæœ
    function addHoverEffects(promptContainer) {
      const originalTags = promptContainer.querySelectorAll('.prompt-tag[data-tag-index]');
      const translationTags = promptContainer.querySelectorAll('.translation-tag[data-tag-index]');

      // ä¸ºåŸå§‹tagsæ·»åŠ æ‚¬åœæ•ˆæœ
      originalTags.forEach(originalTag => {
        const tagIndex = originalTag.dataset.tagIndex;
        const correspondingTranslation = promptContainer.querySelector(`.translation-tag[data-tag-index="${tagIndex}"]`);
        
        originalTag.addEventListener('mouseenter', () => {
          originalTag.classList.add('highlighted');
          if (correspondingTranslation) {
            correspondingTranslation.classList.add('highlighted');
          }
        });
        
        originalTag.addEventListener('mouseleave', () => {
          originalTag.classList.remove('highlighted');
          if (correspondingTranslation) {
            correspondingTranslation.classList.remove('highlighted');
          }
        });
      });

      // ä¸ºç¿»è¯‘tagsæ·»åŠ æ‚¬åœæ•ˆæœ
      translationTags.forEach(translationTag => {
        const tagIndex = translationTag.dataset.tagIndex;
        const correspondingOriginal = promptContainer.querySelector(`.prompt-tag[data-tag-index="${tagIndex}"]`);
        
        translationTag.addEventListener('mouseenter', () => {
          translationTag.classList.add('highlighted');
          if (correspondingOriginal) {
            correspondingOriginal.classList.add('highlighted');
          }
        });
        
        translationTag.addEventListener('mouseleave', () => {
          translationTag.classList.remove('highlighted');
          if (correspondingOriginal) {
            correspondingOriginal.classList.remove('highlighted');
          }
        });
      });
    }

    function createSection(title, icon, items) {
      const section = document.createElement("div");
      section.className = "info-section";

      const titleEl = document.createElement("h2");
      titleEl.className = "section-title";
      titleEl.innerHTML = `<span class="section-icon">${icon}</span>${title}`;
      section.appendChild(titleEl);

      items.forEach((item, index) => {
        // è·³è¿‡æ— æ•ˆçš„é¡¹ç›®
        if (!item || (!item.label && !item.key) || item.value === undefined || item.value === null) {
          console.warn("è·³è¿‡æ— æ•ˆé¡¹ç›®:", item);
          return;
        }

        const itemEl = document.createElement("div");
        itemEl.className = "info-item";
        itemEl.style.animationDelay = `${index * CONFIG.UI.ANIMATION_DELAY_STEP}s`;

        const labelEl = document.createElement("div");
        labelEl.className = "info-label";

        const labelText = document.createElement("span");
        const itemLabel = item.label || item.key || "æœªçŸ¥å­—æ®µ";
        labelText.textContent = itemLabel;
        labelEl.appendChild(labelText);

        // æ£€æŸ¥æ˜¯å¦ä¸ºpromptç›¸å…³å†…å®¹
        const labelToCheck = itemLabel.toLowerCase();
        const isPrompt = labelToCheck.includes("prompt") || labelToCheck.includes("caption") || labelToCheck === "description";

        if (item.copyable) {
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.textContent = "å¤åˆ¶";

          // å¯¹äºpromptç±»å‹ï¼Œå¤åˆ¶æ ¼å¼åŒ–åçš„æ–‡æœ¬ï¼›å¯¹äºå…¶ä»–ç±»å‹ï¼Œå¤åˆ¶åŸå§‹æ–‡æœ¬
          if (isPrompt && item.value && typeof item.value === "string") {
            const formattedText = formatPrompt(item.value);
            copyBtn.onclick = () => copyToClipboard(formattedText);
          } else {
            copyBtn.onclick = () => copyToClipboard(item.value);
          }

          labelEl.appendChild(copyBtn);
        }

        itemEl.appendChild(labelEl);

        const valueEl = document.createElement("div");
        valueEl.className = "info-value";

        if (isPrompt && item.value && typeof item.value === "string") {
          // åˆ¤æ–­æ˜¯å¦ä¸ºè´Ÿé¢prompt
          const isNegativePrompt = labelToCheck.includes("è´Ÿé¢") || labelToCheck.includes("negative");

          // åˆ›å»ºpromptå®¹å™¨
          const promptContainer = document.createElement("div");
          promptContainer.className = "prompt-container";
          
          // å¯¹promptå†…å®¹è¿›è¡Œæ ¼å¼åŒ–å’Œé«˜äº®
          valueEl.classList.add("formatted-prompt");
          valueEl.innerHTML = renderHighlightedPrompt(item.value, isNegativePrompt);
          
          promptContainer.appendChild(valueEl);
          
          // åˆ›å»ºç¿»è¯‘å®¹å™¨
          const translationContainer = document.createElement("div");
          translationContainer.className = "prompt-translation";
          translationContainer.style.display = "none";
          promptContainer.appendChild(translationContainer);
          
          itemEl.appendChild(promptContainer);
          
          // å­˜å‚¨promptä¿¡æ¯ç”¨äºç¿»è¯‘
          promptContainer.dataset.promptIndex = index;
          promptContainer.dataset.promptValue = item.value;
        } else {
          // æ™®é€šæ–‡æœ¬å†…å®¹
          valueEl.textContent = item.value;
          itemEl.appendChild(valueEl);
        }

        section.appendChild(itemEl);
      });

      return section;
    }

    // =============================================================================
    // å›¾ç‰‡é¢„è§ˆå’ŒçŠ¶æ€ç®¡ç†æ¨¡å—
    // =============================================================================
    
    // åº”ç”¨çŠ¶æ€ç®¡ç†
    const AppState = {
      currentFile: null,
      
      setCurrentFile(file) {
        this.currentFile = file;
      },
      
      getCurrentFile() {
        return this.currentFile;
      },
      
      clearCurrentFile() {
        this.currentFile = null;
      }
    };

    // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆå’ŒåŸºæœ¬ä¿¡æ¯
    function showImagePreview(file, modelInfo = null) {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const imageFilename = document.getElementById("imageFilename");
      const imageDetails = document.getElementById("imageDetails");

      // è¯»å–å›¾ç‰‡å¹¶æ˜¾ç¤ºé¢„è§ˆ
      const reader = new FileReader();
      reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewImage.style.display = "block";

        // éšè—ä¸Šä¼ æç¤ºï¼Œæ˜¾ç¤ºå›¾ç‰‡ä¿¡æ¯
        uploadContent.style.display = "none";
        uploadArea.classList.add("has-image");

        // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
        // è®¡ç®—å¯ç”¨å®½åº¦ï¼Œå¤§çº¦æ˜¯å®¹å™¨å®½åº¦å‡å»padding
        const displayFilename = truncateFilename(file.name, CONFIG.UI.FILENAME_MAX_WIDTH);
        imageFilename.textContent = displayFilename;
        imageFilename.title = file.name; // é¼ æ ‡æ‚¬åœæ˜¾ç¤ºå®Œæ•´æ–‡ä»¶å

        // æ·»åŠ ç‚¹å‡»å¤åˆ¶å®Œæ•´æ–‡ä»¶ååŠŸèƒ½
        imageFilename.onclick = () => {
          copyToClipboard(file.name);
        };

        // æ„å»ºè¯¦ç»†ä¿¡æ¯ï¼Œå¦‚æœæœ‰æ¨¡å‹ä¿¡æ¯å°±æ˜¾ç¤ºæ¨¡å‹ï¼Œå¦åˆ™æ˜¾ç¤ºæ–‡ä»¶ç±»å‹
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">${modelInfo ? "æ¨¡å‹:" : "ç±»å‹:"}</span>
                        <span class="detail-value">${modelInfo || file.type}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
        imageInfo.style.display = "block";
      };
      reader.readAsDataURL(file);
    }

    // æ›´æ–°å›¾ç‰‡ä¿¡æ¯ä¸­çš„æ¨¡å‹æ˜¾ç¤º
    function updateImageModelInfo(modelInfo) {
      const imageDetails = document.getElementById("imageDetails");
      const file = AppState.getCurrentFile();

      if (imageDetails && modelInfo && file) {
        const detailsHtml = `
                    <span class="detail-item">
                        <span class="detail-label">å¤§å°:</span>
                        <span class="detail-value">${formatFileSize(file.size)}</span>
                    </span>
                    <span class="detail-item">
                        <span class="detail-label">æ¨¡å‹:</span>
                        <span class="detail-value">${modelInfo}</span>
                    </span>
                `;
        imageDetails.innerHTML = detailsHtml;
      }
    }

    // é‡ç½®ç•Œé¢çš„å‡½æ•°
    function resetInterface() {
      const uploadArea = document.getElementById("uploadArea");
      const uploadContent = document.getElementById("uploadContent");
      const previewImage = document.getElementById("previewImage");
      const imageInfo = document.getElementById("imageInfo");
      const technicalPanel = document.getElementById("technicalPanel");
      const rightPanel = document.getElementById("rightPanel");
      
      uploadArea.classList.remove("has-image");
      uploadContent.style.display = "flex";
      previewImage.style.display = "none";
      imageInfo.style.display = "none";
      technicalPanel.style.display = "none";
      rightPanel.style.display = "none";
      AppState.clearCurrentFile();

      // æ¸…é™¤æ–‡ä»¶åçš„ç‚¹å‡»äº‹ä»¶
      const imageFilename = document.getElementById("imageFilename");
      if (imageFilename) {
        imageFilename.onclick = null;
        imageFilename.title = "";
      }
    }

    // =============================================================================
    // ä¸»è¦å¤„ç†æµç¨‹
    // =============================================================================
    
         // å¤„ç†éšå†™æœ¯æ•°æ®
     async function processStealthExif(imageSrc) {
       console.log("å°è¯•éšå†™æœ¯æå–...");
       const exif = await getStealthExif(imageSrc);
       
       if (!exif) {
         return {
           metaType: CONFIG.METADATA_TYPES.UNKNOWN,
           promptsData: [{
             label: "æç¤º",
             value: "ğŸ˜­ æ— æ³•è¯»å–åˆ°å›¾åƒ Metadataï¼Œè¿™å¯èƒ½ä¸æ˜¯ä¸€å¼  Stable Diffusion ç”Ÿæˆçš„å›¾ã€‚æˆ–è€…ä¸æ˜¯åŸå›¾, ç»è¿‡äº†å‹ç¼©ã€‚",
             copyable: false,
           }],
           stealthExifData: null
         };
       }

      console.log("éšå†™æœ¯æå–æˆåŠŸ:", exif);
      const promptsData = [];

      // å¤„ç†éšå†™æœ¯æ•°æ®
      for (const [key, value] of Object.entries(exif)) {
        if (key === "Comment") {
          // CommentåŒ…å«å®Œæ•´çš„JSONæ•°æ®ï¼Œéœ€è¦è§£æ
          try {
            const jsonData = JSON.parse(value);
            console.log("éšå†™æœ¯Comment JSON data:", jsonData);
            const novelAIData = parseNovelAIData(jsonData);
            promptsData.push(...novelAIData.prompts);
            // è®¾ç½®æŠ€æœ¯å‚æ•°
            renderTechnicalParams(novelAIData.technical);
          } catch (e) {
            console.error("è§£æéšå†™æœ¯Comment JSONå¤±è´¥:", e);
            promptsData.push({
              label: "Comment",
              value: value,
              copyable: true,
            });
          }
        } else if (key === "Description") {
          // Descriptioné€šå¸¸æ˜¯ä¸»prompt
          promptsData.push({
            label: "ä¸»Prompt (Description)",
            value: value,
            copyable: true,
          });
        }
      }

      // æ›´æ–°å›¾ç‰‡æ˜¾ç¤ºä¸­çš„æ¨¡å‹ä¿¡æ¯
      if (exif.Source) {
        updateImageModelInfo(exif.Source);
      }

             return {
         metaType: CONFIG.METADATA_TYPES.NOVELAI,
         promptsData,
         stealthExifData: exif
       };
    }

         // å¤„ç†PNGæ–‡æœ¬å—æ•°æ®
     function processPngTextChunks(metadata) {
       const promptsData = [];
       let metaType = CONFIG.METADATA_TYPES.SD_WEBUI;

      if (metadata.length === 1 && metadata[0].keyword === "parameters") {
        // SD WebUI æ ¼å¼
        const webUIData = handleWebUiTag(metadata[0]);
        promptsData.push(...webUIData);
        renderTechnicalParams([]);
      } else {
        // å¤„ç†PNGæ–‡æœ¬å—ä¸­çš„NovelAI Commentæ ¼å¼
        for (const meta of metadata) {
          if (meta.keyword === "Comment") {
            try {
              const jsonData = JSON.parse(meta.text);
              console.log("PNGæ–‡æœ¬å— NovelAI JSON data:", jsonData);
              const novelAIData = parseNovelAIData(jsonData);
              promptsData.push(...novelAIData.prompts);
              // è®¾ç½®æŠ€æœ¯å‚æ•°
              renderTechnicalParams(novelAIData.technical);
              metaType = CONFIG.METADATA_TYPES.NOVELAI;
            } catch (e) {
              console.error("è§£æPNGæ–‡æœ¬å—Comment JSONå¤±è´¥:", e);
              promptsData.push({
                label: meta.keyword,
                value: meta.text,
                copyable: true,
              });
            }
          } else if (meta.keyword === "Source") {
            // æ›´æ–°æ¨¡å‹ä¿¡æ¯æ˜¾ç¤º
            if (meta.text) {
              updateImageModelInfo(meta.text);
            }
          } else if (meta.keyword === "Description") {
            promptsData.push({
              label: "ä¸»Prompt (Description)",
              value: meta.text,
              copyable: true,
            });
          } else if (meta.keyword !== "Software" && meta.keyword !== "Generation time") {
            // å…¶ä»–éåŸºç¡€ä¿¡æ¯çš„å­—æ®µä½œä¸ºpromptå¤„ç†
            promptsData.push({
              label: meta.keyword,
              value: meta.text,
              copyable: true,
            });
          }
        }
      }

      return { metaType, promptsData };
    }

    // æ„å»ºåŸºç¡€ä¿¡æ¯
    function buildBasicInfo(file, metaType, stealthExifData) {
      const basicInfo = [
        { label: "æ–‡ä»¶å", value: file.name },
        { label: "æ–‡ä»¶å¤§å°", value: formatFileSize(file.size) },
      ];

             // å¦‚æœæœ‰æ¨¡å‹ä¿¡æ¯ï¼Œæ·»åŠ åˆ°åŸºç¡€ä¿¡æ¯ä¸­
       if (metaType === CONFIG.METADATA_TYPES.NOVELAI && stealthExifData) {
        if (stealthExifData.Software) {
          basicInfo.push({ label: "è½¯ä»¶", value: stealthExifData.Software });
        }
        if (stealthExifData.Source) {
          basicInfo.push({ label: "æ¨¡å‹", value: stealthExifData.Source });
        }
        if (stealthExifData["Generation time"]) {
          basicInfo.push({ label: "ç”Ÿæˆæ—¶é—´", value: stealthExifData["Generation time"] + "s" });
        }
      }

      return basicInfo;
    }

    // å¤„ç†å›¾ç‰‡ä¸»å‡½æ•°
    async function processImage(file) {
      const rightPanel = document.getElementById("rightPanel");

      // ä¿å­˜å½“å‰æ–‡ä»¶å¼•ç”¨ç”¨äºåç»­æ›´æ–°
      AppState.setCurrentFile(file);

      // æ˜¾ç¤ºå›¾ç‰‡é¢„è§ˆ
      showImagePreview(file);

      // è¯»å–å›¾ç‰‡ä½œä¸ºDataURLç”¨äºéšå†™æœ¯æå–
      const reader = new FileReader();
      reader.onload = async (e) => {
        const imageSrc = e.target.result;

        try {
          // æå–å…ƒæ•°æ®
          const metadata = await extractMetadata(file);
          console.log("æå–çš„å…ƒæ•°æ®:", metadata);

          let metaType, promptsData, stealthExifData = null;

          if (metadata.length === 0) {
            // å°è¯•éšå†™æœ¯æå–
            const stealthResult = await processStealthExif(imageSrc);
            metaType = stealthResult.metaType;
            promptsData = stealthResult.promptsData;
            stealthExifData = stealthResult.stealthExifData;
          } else {
            // å¤„ç†PNGæ–‡æœ¬å—
            const pngResult = processPngTextChunks(metadata);
            metaType = pngResult.metaType;
            promptsData = pngResult.promptsData;
          }

          // æ„å»ºå®Œæ•´æ•°æ®ç»“æ„
          const basicInfo = buildBasicInfo(file, metaType, stealthExifData);
          const allData = {
            basic: basicInfo,
            prompts: promptsData,
            technical: [],
            exif: [],
          };

                     // æ·»åŠ SD-WEBUIå®Œæ•´ä¿¡æ¯
           if (metaType === CONFIG.METADATA_TYPES.SD_WEBUI && metadata.length > 0) {
            allData.prompts.push({
              key: "å®Œæ•´ç”Ÿæˆä¿¡æ¯",
              value: metadata[0]["text"],
              copyable: true,
            });
          }

                     // å¦‚æœä¸æ˜¯NovelAIæ ¼å¼ï¼Œæ¸²æŸ“ç©ºçš„æŠ€æœ¯å‚æ•°
           if (metaType !== CONFIG.METADATA_TYPES.NOVELAI) {
            renderTechnicalParams([]);
          }

          // æ¸²æŸ“ä¿¡æ¯åˆ°å³ä¾§
          renderInfo(allData);
          rightPanel.style.display = "block";

                 } catch (error) {
           ErrorHandler.handleProcessingError(error, "å¤„ç†å›¾ç‰‡");
         }
      };

      reader.readAsDataURL(file);
    }

    // =============================================================================
    // åˆå§‹åŒ–å’Œäº‹ä»¶ç»‘å®š
    // =============================================================================
    
    // =============================================================================
    // è®¾ç½®é¢æ¿åŠŸèƒ½
    // =============================================================================
    
    function initializeSettings() {
      const settingsBtn = document.getElementById('settingsBtn');
      const settingsModal = document.getElementById('settingsModal');
      const closeSettingsBtn = document.getElementById('closeSettingsBtn');
      
      // æ‰€æœ‰è¾“å…¥å…ƒç´ 
      const translationToggle = document.getElementById('translationToggle');
      const translationProviderSelect = document.getElementById('translationProviderSelect');
      
      // Gemini é…ç½®
      const apiKeyInput = document.getElementById('apiKeyInput');
      
      // è…¾è®¯äº‘é…ç½®
      const tencentSecretIdInput = document.getElementById('tencentSecretIdInput');
      const tencentSecretKeyInput = document.getElementById('tencentSecretKeyInput');
      
      // ç™¾åº¦ç¿»è¯‘é…ç½®
      const baiduAppIdInput = document.getElementById('baiduAppIdInput');
      const baiduAppKeyInput = document.getElementById('baiduAppKeyInput');
      
      // æŒ‰é’®
      const saveSettingsBtn = document.getElementById('saveSettingsBtn');
      const testConnectionBtn = document.getElementById('testConnectionBtn');

      // æ˜¾ç¤º/éšè—é…ç½®åŒºåŸŸ
      function showProviderConfig(provider) {
        const configs = ['geminiConfig', 'tencentConfig', 'baiduConfig'];
        configs.forEach(configId => {
          const config = document.getElementById(configId);
          if (config) {
            config.style.display = configId === `${provider}Config` ? 'block' : 'none';
          }
        });
      }

      // åŠ è½½è®¾ç½®
      function loadSettings() {
        // ç¿»è¯‘å¼€å…³
        if (SettingsManager.isTranslationEnabled()) {
          translationToggle.classList.add('active');
        } else {
          translationToggle.classList.remove('active');
        }

        // ç¿»è¯‘æœåŠ¡æä¾›å•†
        const provider = SettingsManager.getTranslationProvider();
        translationProviderSelect.value = provider;
        showProviderConfig(provider);

        // Gemini é…ç½®
        apiKeyInput.value = SettingsManager.getApiKey();

        // è…¾è®¯äº‘é…ç½®
        tencentSecretIdInput.value = SettingsManager.getTencentSecretId();
        tencentSecretKeyInput.value = SettingsManager.getTencentSecretKey();

        // ç™¾åº¦ç¿»è¯‘é…ç½®
        baiduAppIdInput.value = SettingsManager.getBaiduAppId();
        baiduAppKeyInput.value = SettingsManager.getBaiduAppKey();
      }

      // ä¿å­˜è®¾ç½®
      function saveSettings() {
        const translationEnabled = translationToggle.classList.contains('active');
        const provider = translationProviderSelect.value;

        // ä¿å­˜åŸºæœ¬è®¾ç½®
        SettingsManager.setTranslationEnabled(translationEnabled);
        SettingsManager.setTranslationProvider(provider);

        // ä¿å­˜APIå¯†é’¥é…ç½®
        SettingsManager.setApiKey(apiKeyInput.value.trim());
        SettingsManager.setTencentSecretId(tencentSecretIdInput.value.trim());
        SettingsManager.setTencentSecretKey(tencentSecretKeyInput.value.trim());
        SettingsManager.setBaiduAppId(baiduAppIdInput.value.trim());
        SettingsManager.setBaiduAppKey(baiduAppKeyInput.value.trim());

        showToast('è®¾ç½®å·²ä¿å­˜');
        closeSettings();
      }

      // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
      function showTestResult(type, message) {
        const testResult = document.getElementById('testResult');
        const testResultContent = document.getElementById('testResultContent');
        
        testResult.className = `test-result ${type}`;
        testResultContent.innerHTML = message;
        testResult.style.display = 'block';
      }

      // éšè—æµ‹è¯•ç»“æœ
      function hideTestResult() {
        const testResult = document.getElementById('testResult');
        testResult.style.display = 'none';
      }

      // æµ‹è¯•è¿æ¥
      async function testConnection() {
        const provider = translationProviderSelect.value;
        testConnectionBtn.disabled = true;
        testConnectionBtn.textContent = 'æµ‹è¯•ä¸­...';
        
        // æ˜¾ç¤ºæµ‹è¯•ä¸­çŠ¶æ€
        showTestResult('loading', 'ğŸ”„ æ­£åœ¨æµ‹è¯•è¿æ¥ï¼Œè¯·ç¨å€™...');

        try {
          // æ£€æŸ¥é…ç½®
          let hasValidConfig = false;
          let configError = '';
          
          switch (provider) {
            case 'gemini':
              hasValidConfig = apiKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = 'è¯·å¡«å†™ Gemini API Key';
              break;
            case 'tencent':
              hasValidConfig = tencentSecretIdInput.value.trim().length > 0 && 
                              tencentSecretKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = 'è¯·å¡«å†™è…¾è®¯äº‘ Secret ID å’Œ Secret Key';
              break;
            case 'baidu':
              hasValidConfig = baiduAppIdInput.value.trim().length > 0 && 
                              baiduAppKeyInput.value.trim().length > 0;
              if (!hasValidConfig) configError = 'è¯·å¡«å†™ç™¾åº¦ç¿»è¯‘ App ID å’Œ App Key';
              break;
          }

          if (!hasValidConfig) {
            throw new Error(configError);
          }

          // ä¸´æ—¶ä¿å­˜é…ç½®
          const originalProvider = SettingsManager.getTranslationProvider();
          const originalConfigs = {};
          
          // å¤‡ä»½åŸå§‹é…ç½®
          originalConfigs.geminiKey = SettingsManager.getApiKey();
          originalConfigs.tencentId = SettingsManager.getTencentSecretId();
          originalConfigs.tencentKey = SettingsManager.getTencentSecretKey();
          originalConfigs.baiduId = SettingsManager.getBaiduAppId();
          originalConfigs.baiduKey = SettingsManager.getBaiduAppKey();

          // è®¾ç½®æµ‹è¯•é…ç½®
          SettingsManager.setTranslationProvider(provider);
          SettingsManager.setApiKey(apiKeyInput.value.trim());
          SettingsManager.setTencentSecretId(tencentSecretIdInput.value.trim());
          SettingsManager.setTencentSecretKey(tencentSecretKeyInput.value.trim());
          SettingsManager.setBaiduAppId(baiduAppIdInput.value.trim());
          SettingsManager.setBaiduAppKey(baiduAppKeyInput.value.trim());

          // æµ‹è¯•ç¿»è¯‘ï¼ˆä¸ä½¿ç”¨ç¼“å­˜ï¼Œç›´æ¥æµ‹è¯•APIï¼‰
          const testTags = ['test'];
          const result = await TranslationManager.translateTags(testTags, provider);

          if (result && result.length > 0) {
            showTestResult('success', `âœ… <strong>${provider}</strong> è¿æ¥æµ‹è¯•æˆåŠŸï¼<br>ç¿»è¯‘ç»“æœï¼š<strong>${result[0]}</strong>`);
          } else {
            throw new Error('ç¿»è¯‘è¿”å›ç»“æœä¸ºç©º');
          }

          // æ¢å¤åŸå§‹é…ç½®
          SettingsManager.setTranslationProvider(originalProvider);
          SettingsManager.setApiKey(originalConfigs.geminiKey);
          SettingsManager.setTencentSecretId(originalConfigs.tencentId);
          SettingsManager.setTencentSecretKey(originalConfigs.tencentKey);
          SettingsManager.setBaiduAppId(originalConfigs.baiduId);
          SettingsManager.setBaiduAppKey(originalConfigs.baiduKey);

        } catch (error) {
          console.error('è¿æ¥æµ‹è¯•å¤±è´¥:', error);
          let errorMessage = error.message;
          
          // é’ˆå¯¹ä¸åŒé”™è¯¯ç±»å‹æä¾›ç‰¹æ®Šæç¤º
          if (errorMessage.includes('CORS') || errorMessage.includes('ç½‘ç»œ') || 
              errorMessage.includes('Failed to fetch') || errorMessage.includes('Access to fetch')) {
            if (provider === 'tencent' || provider === 'baidu') {
              errorMessage = `âŒ <strong>${provider}</strong> è¿æ¥å¤±è´¥<br><br>
                <strong>CORS è·¨åŸŸé”™è¯¯</strong><br>
                ğŸ’¡ è¯·å®‰è£…ä»¥ä¸‹ä»»ä¸€è§£å†³æ–¹æ¡ˆï¼š<br>
                â€¢ Chrome æ’ä»¶ï¼šCORS Unblock<br>
                â€¢ Tampermonkey è„šæœ¬ï¼šnovelai-translator-cors.user.js<br>
                â€¢ è¯¦è§é…ç½®æŒ‡å—æ–‡æ¡£`;
            }
          } else if (errorMessage.includes('Invalid Sign') || errorMessage.includes('54001')) {
            errorMessage = `âŒ <strong>${provider}</strong> ç­¾åé”™è¯¯<br><br>
              <strong>å¯èƒ½çš„åŸå› ï¼š</strong><br>
              â€¢ API å¯†é’¥ä¸æ­£ç¡®<br>
              â€¢ App ID æˆ– App Key è¾“å…¥é”™è¯¯<br>
              â€¢ è¯·æ£€æŸ¥é…ç½®ä¿¡æ¯æ˜¯å¦å®Œæ•´`;
          } else if (errorMessage.includes('API')) {
            errorMessage = `âŒ <strong>${provider}</strong> API é”™è¯¯<br><br>
              <strong>é”™è¯¯ä¿¡æ¯ï¼š</strong> ${errorMessage}`;
          } else {
            errorMessage = `âŒ <strong>${provider}</strong> è¿æ¥å¤±è´¥<br><br>
              <strong>é”™è¯¯ä¿¡æ¯ï¼š</strong> ${errorMessage}`;
          }
          
          showTestResult('error', errorMessage);
        } finally {
          testConnectionBtn.disabled = false;
          testConnectionBtn.textContent = 'æµ‹è¯•è¿æ¥';
        }
      }

      // æ‰“å¼€è®¾ç½®é¢æ¿
      function openSettings() {
        loadSettings();
        settingsModal.classList.add('show');
      }

      // å…³é—­è®¾ç½®é¢æ¿
      function closeSettings() {
        settingsModal.classList.remove('show');
      }

      // äº‹ä»¶ç»‘å®š
      settingsBtn.addEventListener('click', openSettings);
      closeSettingsBtn.addEventListener('click', closeSettings);
      
      // ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
      settingsModal.addEventListener('click', (e) => {
        if (e.target === settingsModal) {
          closeSettings();
        }
      });

      // ç¿»è¯‘æœåŠ¡æä¾›å•†åˆ‡æ¢
      translationProviderSelect.addEventListener('change', (e) => {
        showProviderConfig(e.target.value);
        hideTestResult(); // åˆ‡æ¢æœåŠ¡æ—¶éšè—ä¹‹å‰çš„æµ‹è¯•ç»“æœ
      });

      // åˆ‡æ¢å¼€å…³
      translationToggle.addEventListener('click', () => {
        translationToggle.classList.toggle('active');
      });

      // ä¿å­˜æŒ‰é’®
      saveSettingsBtn.addEventListener('click', saveSettings);

      // æµ‹è¯•è¿æ¥æŒ‰é’®
      testConnectionBtn.addEventListener('click', testConnection);

      // ESCé”®å…³é—­
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && settingsModal.classList.contains('show')) {
          closeSettings();
        }
      });

      // åˆå§‹åŠ è½½è®¾ç½®
      loadSettings();
    }

    // åˆå§‹åŒ–ä¸Šä¼ åŠŸèƒ½
    document.addEventListener("DOMContentLoaded", () => {
      // åˆå§‹åŒ–è®¾ç½®åŠŸèƒ½
      initializeSettings();
      
      // é¢„åŠ è½½ç¿»è¯‘ç¼“å­˜ï¼ˆæ— è®ºæ˜¯å¦å¼€å¯ç¿»è¯‘ï¼Œéƒ½é¢„åŠ è½½ä»¥æé«˜æ€§èƒ½ï¼‰
      TranslationManager.loadLocalCache();
      
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");

      uploadArea.addEventListener("click", (e) => {
        // å¦‚æœç‚¹å‡»çš„æ˜¯å›¾ç‰‡ï¼Œè¯¢é—®æ˜¯å¦è¦é€‰æ‹©æ–°å›¾ç‰‡
        if (e.target.tagName === "IMG" && e.target.id === "previewImage") {
          if (confirm("è¦é€‰æ‹©æ–°çš„å›¾ç‰‡å—ï¼Ÿ")) {
            resetInterface();
            fileInput.click();
          }
        } else if (!uploadArea.classList.contains("has-image")) {
          // å¦‚æœè¿˜æ²¡æœ‰å›¾ç‰‡ï¼Œç›´æ¥æ‰“å¼€é€‰æ‹©
          fileInput.click();
        }
      });

      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
        // æ¸…ç©ºinputï¼Œå…è®¸é‡å¤é€‰æ‹©åŒä¸€æ–‡ä»¶
        fileInput.value = "";
      });

      // æ‹–æ‹½åŠŸèƒ½
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("drag-over");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("drag-over");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("drag-over");

        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          processImage(file);
        }
      });
    });
  </script>
</body>

</html>